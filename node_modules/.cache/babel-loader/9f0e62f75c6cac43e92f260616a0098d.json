{"ast":null,"code":"(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@zilliqa-js/account'), require('@zilliqa-js/core'), require('@zilliqa-js/crypto'), require('@zilliqa-js/util')) : typeof define === 'function' && define.amd ? define(['exports', '@zilliqa-js/account', '@zilliqa-js/core', '@zilliqa-js/crypto', '@zilliqa-js/util'], factory) : factory(global.zjsContract = {}, global.zjsAccount, global.zjsCore, global.zjsCrypto, global.zjsUtil);\n})(this, function (exports, account, core, crypto, util) {\n  'use strict';\n\n  function createCommonjsModule(fn, module) {\n    return module = {\n      exports: {}\n    }, fn(module, module.exports), module.exports;\n  }\n\n  var minimalisticAssert = assert;\n\n  function assert(val, msg) {\n    if (!val) throw new Error(msg || 'Assertion failed');\n  }\n\n  assert.equal = function assertEqual(l, r, msg) {\n    if (l != r) throw new Error(msg || 'Assertion failed: ' + l + ' != ' + r);\n  };\n\n  var inherits_browser = createCommonjsModule(function (module) {\n    if (typeof Object.create === 'function') {\n      // implementation from standard node.js 'util' module\n      module.exports = function inherits(ctor, superCtor) {\n        if (superCtor) {\n          ctor.super_ = superCtor;\n          ctor.prototype = Object.create(superCtor.prototype, {\n            constructor: {\n              value: ctor,\n              enumerable: false,\n              writable: true,\n              configurable: true\n            }\n          });\n        }\n      };\n    } else {\n      // old school shim for old browsers\n      module.exports = function inherits(ctor, superCtor) {\n        if (superCtor) {\n          ctor.super_ = superCtor;\n\n          var TempCtor = function () {};\n\n          TempCtor.prototype = superCtor.prototype;\n          ctor.prototype = new TempCtor();\n          ctor.prototype.constructor = ctor;\n        }\n      };\n    }\n  });\n  var inherits_1 = inherits_browser;\n\n  function isSurrogatePair(msg, i) {\n    if ((msg.charCodeAt(i) & 0xFC00) !== 0xD800) {\n      return false;\n    }\n\n    if (i < 0 || i + 1 >= msg.length) {\n      return false;\n    }\n\n    return (msg.charCodeAt(i + 1) & 0xFC00) === 0xDC00;\n  }\n\n  function toArray(msg, enc) {\n    if (Array.isArray(msg)) return msg.slice();\n    if (!msg) return [];\n    var res = [];\n\n    if (typeof msg === 'string') {\n      if (!enc) {\n        // Inspired by stringToUtf8ByteArray() in closure-library by Google\n        // https://github.com/google/closure-library/blob/8598d87242af59aac233270742c8984e2b2bdbe0/closure/goog/crypt/crypt.js#L117-L143\n        // Apache License 2.0\n        // https://github.com/google/closure-library/blob/master/LICENSE\n        var p = 0;\n\n        for (var i = 0; i < msg.length; i++) {\n          var c = msg.charCodeAt(i);\n\n          if (c < 128) {\n            res[p++] = c;\n          } else if (c < 2048) {\n            res[p++] = c >> 6 | 192;\n            res[p++] = c & 63 | 128;\n          } else if (isSurrogatePair(msg, i)) {\n            c = 0x10000 + ((c & 0x03FF) << 10) + (msg.charCodeAt(++i) & 0x03FF);\n            res[p++] = c >> 18 | 240;\n            res[p++] = c >> 12 & 63 | 128;\n            res[p++] = c >> 6 & 63 | 128;\n            res[p++] = c & 63 | 128;\n          } else {\n            res[p++] = c >> 12 | 224;\n            res[p++] = c >> 6 & 63 | 128;\n            res[p++] = c & 63 | 128;\n          }\n        }\n      } else if (enc === 'hex') {\n        msg = msg.replace(/[^a-z0-9]+/ig, '');\n        if (msg.length % 2 !== 0) msg = '0' + msg;\n\n        for (i = 0; i < msg.length; i += 2) res.push(parseInt(msg[i] + msg[i + 1], 16));\n      }\n    } else {\n      for (i = 0; i < msg.length; i++) res[i] = msg[i] | 0;\n    }\n\n    return res;\n  }\n\n  var toArray_1 = toArray;\n\n  function toHex(msg) {\n    var res = '';\n\n    for (var i = 0; i < msg.length; i++) res += zero2(msg[i].toString(16));\n\n    return res;\n  }\n\n  var toHex_1 = toHex;\n\n  function htonl(w) {\n    var res = w >>> 24 | w >>> 8 & 0xff00 | w << 8 & 0xff0000 | (w & 0xff) << 24;\n    return res >>> 0;\n  }\n\n  var htonl_1 = htonl;\n\n  function toHex32(msg, endian) {\n    var res = '';\n\n    for (var i = 0; i < msg.length; i++) {\n      var w = msg[i];\n      if (endian === 'little') w = htonl(w);\n      res += zero8(w.toString(16));\n    }\n\n    return res;\n  }\n\n  var toHex32_1 = toHex32;\n\n  function zero2(word) {\n    if (word.length === 1) return '0' + word;else return word;\n  }\n\n  var zero2_1 = zero2;\n\n  function zero8(word) {\n    if (word.length === 7) return '0' + word;else if (word.length === 6) return '00' + word;else if (word.length === 5) return '000' + word;else if (word.length === 4) return '0000' + word;else if (word.length === 3) return '00000' + word;else if (word.length === 2) return '000000' + word;else if (word.length === 1) return '0000000' + word;else return word;\n  }\n\n  var zero8_1 = zero8;\n\n  function join32(msg, start, end, endian) {\n    var len = end - start;\n    minimalisticAssert(len % 4 === 0);\n    var res = new Array(len / 4);\n\n    for (var i = 0, k = start; i < res.length; i++, k += 4) {\n      var w;\n      if (endian === 'big') w = msg[k] << 24 | msg[k + 1] << 16 | msg[k + 2] << 8 | msg[k + 3];else w = msg[k + 3] << 24 | msg[k + 2] << 16 | msg[k + 1] << 8 | msg[k];\n      res[i] = w >>> 0;\n    }\n\n    return res;\n  }\n\n  var join32_1 = join32;\n\n  function split32(msg, endian) {\n    var res = new Array(msg.length * 4);\n\n    for (var i = 0, k = 0; i < msg.length; i++, k += 4) {\n      var m = msg[i];\n\n      if (endian === 'big') {\n        res[k] = m >>> 24;\n        res[k + 1] = m >>> 16 & 0xff;\n        res[k + 2] = m >>> 8 & 0xff;\n        res[k + 3] = m & 0xff;\n      } else {\n        res[k + 3] = m >>> 24;\n        res[k + 2] = m >>> 16 & 0xff;\n        res[k + 1] = m >>> 8 & 0xff;\n        res[k] = m & 0xff;\n      }\n    }\n\n    return res;\n  }\n\n  var split32_1 = split32;\n\n  function rotr32(w, b) {\n    return w >>> b | w << 32 - b;\n  }\n\n  var rotr32_1 = rotr32;\n\n  function rotl32(w, b) {\n    return w << b | w >>> 32 - b;\n  }\n\n  var rotl32_1 = rotl32;\n\n  function sum32(a, b) {\n    return a + b >>> 0;\n  }\n\n  var sum32_1 = sum32;\n\n  function sum32_3(a, b, c) {\n    return a + b + c >>> 0;\n  }\n\n  var sum32_3_1 = sum32_3;\n\n  function sum32_4(a, b, c, d) {\n    return a + b + c + d >>> 0;\n  }\n\n  var sum32_4_1 = sum32_4;\n\n  function sum32_5(a, b, c, d, e) {\n    return a + b + c + d + e >>> 0;\n  }\n\n  var sum32_5_1 = sum32_5;\n\n  function sum64(buf, pos, ah, al) {\n    var bh = buf[pos];\n    var bl = buf[pos + 1];\n    var lo = al + bl >>> 0;\n    var hi = (lo < al ? 1 : 0) + ah + bh;\n    buf[pos] = hi >>> 0;\n    buf[pos + 1] = lo;\n  }\n\n  var sum64_1 = sum64;\n\n  function sum64_hi(ah, al, bh, bl) {\n    var lo = al + bl >>> 0;\n    var hi = (lo < al ? 1 : 0) + ah + bh;\n    return hi >>> 0;\n  }\n\n  var sum64_hi_1 = sum64_hi;\n\n  function sum64_lo(ah, al, bh, bl) {\n    var lo = al + bl;\n    return lo >>> 0;\n  }\n\n  var sum64_lo_1 = sum64_lo;\n\n  function sum64_4_hi(ah, al, bh, bl, ch, cl, dh, dl) {\n    var carry = 0;\n    var lo = al;\n    lo = lo + bl >>> 0;\n    carry += lo < al ? 1 : 0;\n    lo = lo + cl >>> 0;\n    carry += lo < cl ? 1 : 0;\n    lo = lo + dl >>> 0;\n    carry += lo < dl ? 1 : 0;\n    var hi = ah + bh + ch + dh + carry;\n    return hi >>> 0;\n  }\n\n  var sum64_4_hi_1 = sum64_4_hi;\n\n  function sum64_4_lo(ah, al, bh, bl, ch, cl, dh, dl) {\n    var lo = al + bl + cl + dl;\n    return lo >>> 0;\n  }\n\n  var sum64_4_lo_1 = sum64_4_lo;\n\n  function sum64_5_hi(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {\n    var carry = 0;\n    var lo = al;\n    lo = lo + bl >>> 0;\n    carry += lo < al ? 1 : 0;\n    lo = lo + cl >>> 0;\n    carry += lo < cl ? 1 : 0;\n    lo = lo + dl >>> 0;\n    carry += lo < dl ? 1 : 0;\n    lo = lo + el >>> 0;\n    carry += lo < el ? 1 : 0;\n    var hi = ah + bh + ch + dh + eh + carry;\n    return hi >>> 0;\n  }\n\n  var sum64_5_hi_1 = sum64_5_hi;\n\n  function sum64_5_lo(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {\n    var lo = al + bl + cl + dl + el;\n    return lo >>> 0;\n  }\n\n  var sum64_5_lo_1 = sum64_5_lo;\n\n  function rotr64_hi(ah, al, num) {\n    var r = al << 32 - num | ah >>> num;\n    return r >>> 0;\n  }\n\n  var rotr64_hi_1 = rotr64_hi;\n\n  function rotr64_lo(ah, al, num) {\n    var r = ah << 32 - num | al >>> num;\n    return r >>> 0;\n  }\n\n  var rotr64_lo_1 = rotr64_lo;\n\n  function shr64_hi(ah, al, num) {\n    return ah >>> num;\n  }\n\n  var shr64_hi_1 = shr64_hi;\n\n  function shr64_lo(ah, al, num) {\n    var r = ah << 32 - num | al >>> num;\n    return r >>> 0;\n  }\n\n  var shr64_lo_1 = shr64_lo;\n  var utils = {\n    inherits: inherits_1,\n    toArray: toArray_1,\n    toHex: toHex_1,\n    htonl: htonl_1,\n    toHex32: toHex32_1,\n    zero2: zero2_1,\n    zero8: zero8_1,\n    join32: join32_1,\n    split32: split32_1,\n    rotr32: rotr32_1,\n    rotl32: rotl32_1,\n    sum32: sum32_1,\n    sum32_3: sum32_3_1,\n    sum32_4: sum32_4_1,\n    sum32_5: sum32_5_1,\n    sum64: sum64_1,\n    sum64_hi: sum64_hi_1,\n    sum64_lo: sum64_lo_1,\n    sum64_4_hi: sum64_4_hi_1,\n    sum64_4_lo: sum64_4_lo_1,\n    sum64_5_hi: sum64_5_hi_1,\n    sum64_5_lo: sum64_5_lo_1,\n    rotr64_hi: rotr64_hi_1,\n    rotr64_lo: rotr64_lo_1,\n    shr64_hi: shr64_hi_1,\n    shr64_lo: shr64_lo_1\n  };\n\n  function BlockHash() {\n    this.pending = null;\n    this.pendingTotal = 0;\n    this.blockSize = this.constructor.blockSize;\n    this.outSize = this.constructor.outSize;\n    this.hmacStrength = this.constructor.hmacStrength;\n    this.padLength = this.constructor.padLength / 8;\n    this.endian = 'big';\n    this._delta8 = this.blockSize / 8;\n    this._delta32 = this.blockSize / 32;\n  }\n\n  var BlockHash_1 = BlockHash;\n\n  BlockHash.prototype.update = function update(msg, enc) {\n    // Convert message to array, pad it, and join into 32bit blocks\n    msg = utils.toArray(msg, enc);\n    if (!this.pending) this.pending = msg;else this.pending = this.pending.concat(msg);\n    this.pendingTotal += msg.length; // Enough data, try updating\n\n    if (this.pending.length >= this._delta8) {\n      msg = this.pending; // Process pending data in blocks\n\n      var r = msg.length % this._delta8;\n      this.pending = msg.slice(msg.length - r, msg.length);\n      if (this.pending.length === 0) this.pending = null;\n      msg = utils.join32(msg, 0, msg.length - r, this.endian);\n\n      for (var i = 0; i < msg.length; i += this._delta32) this._update(msg, i, i + this._delta32);\n    }\n\n    return this;\n  };\n\n  BlockHash.prototype.digest = function digest(enc) {\n    this.update(this._pad());\n    minimalisticAssert(this.pending === null);\n    return this._digest(enc);\n  };\n\n  BlockHash.prototype._pad = function pad() {\n    var len = this.pendingTotal;\n    var bytes = this._delta8;\n    var k = bytes - (len + this.padLength) % bytes;\n    var res = new Array(k + this.padLength);\n    res[0] = 0x80;\n\n    for (var i = 1; i < k; i++) res[i] = 0; // Append length\n\n\n    len <<= 3;\n\n    if (this.endian === 'big') {\n      for (var t = 8; t < this.padLength; t++) res[i++] = 0;\n\n      res[i++] = 0;\n      res[i++] = 0;\n      res[i++] = 0;\n      res[i++] = 0;\n      res[i++] = len >>> 24 & 0xff;\n      res[i++] = len >>> 16 & 0xff;\n      res[i++] = len >>> 8 & 0xff;\n      res[i++] = len & 0xff;\n    } else {\n      res[i++] = len & 0xff;\n      res[i++] = len >>> 8 & 0xff;\n      res[i++] = len >>> 16 & 0xff;\n      res[i++] = len >>> 24 & 0xff;\n      res[i++] = 0;\n      res[i++] = 0;\n      res[i++] = 0;\n      res[i++] = 0;\n\n      for (t = 8; t < this.padLength; t++) res[i++] = 0;\n    }\n\n    return res;\n  };\n\n  var common = {\n    BlockHash: BlockHash_1\n  };\n  var rotr32$1 = utils.rotr32;\n\n  function ft_1(s, x, y, z) {\n    if (s === 0) return ch32(x, y, z);\n    if (s === 1 || s === 3) return p32(x, y, z);\n    if (s === 2) return maj32(x, y, z);\n  }\n\n  var ft_1_1 = ft_1;\n\n  function ch32(x, y, z) {\n    return x & y ^ ~x & z;\n  }\n\n  var ch32_1 = ch32;\n\n  function maj32(x, y, z) {\n    return x & y ^ x & z ^ y & z;\n  }\n\n  var maj32_1 = maj32;\n\n  function p32(x, y, z) {\n    return x ^ y ^ z;\n  }\n\n  var p32_1 = p32;\n\n  function s0_256(x) {\n    return rotr32$1(x, 2) ^ rotr32$1(x, 13) ^ rotr32$1(x, 22);\n  }\n\n  var s0_256_1 = s0_256;\n\n  function s1_256(x) {\n    return rotr32$1(x, 6) ^ rotr32$1(x, 11) ^ rotr32$1(x, 25);\n  }\n\n  var s1_256_1 = s1_256;\n\n  function g0_256(x) {\n    return rotr32$1(x, 7) ^ rotr32$1(x, 18) ^ x >>> 3;\n  }\n\n  var g0_256_1 = g0_256;\n\n  function g1_256(x) {\n    return rotr32$1(x, 17) ^ rotr32$1(x, 19) ^ x >>> 10;\n  }\n\n  var g1_256_1 = g1_256;\n  var common$1 = {\n    ft_1: ft_1_1,\n    ch32: ch32_1,\n    maj32: maj32_1,\n    p32: p32_1,\n    s0_256: s0_256_1,\n    s1_256: s1_256_1,\n    g0_256: g0_256_1,\n    g1_256: g1_256_1\n  };\n  var rotl32$1 = utils.rotl32;\n  var sum32$1 = utils.sum32;\n  var sum32_5$1 = utils.sum32_5;\n  var ft_1$1 = common$1.ft_1;\n  var BlockHash$1 = common.BlockHash;\n  var sha1_K = [0x5A827999, 0x6ED9EBA1, 0x8F1BBCDC, 0xCA62C1D6];\n\n  function SHA1() {\n    if (!(this instanceof SHA1)) return new SHA1();\n    BlockHash$1.call(this);\n    this.h = [0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0];\n    this.W = new Array(80);\n  }\n\n  utils.inherits(SHA1, BlockHash$1);\n  var _1 = SHA1;\n  SHA1.blockSize = 512;\n  SHA1.outSize = 160;\n  SHA1.hmacStrength = 80;\n  SHA1.padLength = 64;\n\n  SHA1.prototype._update = function _update(msg, start) {\n    var W = this.W;\n\n    for (var i = 0; i < 16; i++) W[i] = msg[start + i];\n\n    for (; i < W.length; i++) W[i] = rotl32$1(W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16], 1);\n\n    var a = this.h[0];\n    var b = this.h[1];\n    var c = this.h[2];\n    var d = this.h[3];\n    var e = this.h[4];\n\n    for (i = 0; i < W.length; i++) {\n      var s = ~~(i / 20);\n      var t = sum32_5$1(rotl32$1(a, 5), ft_1$1(s, b, c, d), e, W[i], sha1_K[s]);\n      e = d;\n      d = c;\n      c = rotl32$1(b, 30);\n      b = a;\n      a = t;\n    }\n\n    this.h[0] = sum32$1(this.h[0], a);\n    this.h[1] = sum32$1(this.h[1], b);\n    this.h[2] = sum32$1(this.h[2], c);\n    this.h[3] = sum32$1(this.h[3], d);\n    this.h[4] = sum32$1(this.h[4], e);\n  };\n\n  SHA1.prototype._digest = function digest(enc) {\n    if (enc === 'hex') return utils.toHex32(this.h, 'big');else return utils.split32(this.h, 'big');\n  };\n\n  var sum32$2 = utils.sum32;\n  var sum32_4$1 = utils.sum32_4;\n  var sum32_5$2 = utils.sum32_5;\n  var ch32$1 = common$1.ch32;\n  var maj32$1 = common$1.maj32;\n  var s0_256$1 = common$1.s0_256;\n  var s1_256$1 = common$1.s1_256;\n  var g0_256$1 = common$1.g0_256;\n  var g1_256$1 = common$1.g1_256;\n  var BlockHash$2 = common.BlockHash;\n  var sha256_K = [0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5, 0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174, 0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da, 0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967, 0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85, 0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070, 0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3, 0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2];\n\n  function SHA256() {\n    if (!(this instanceof SHA256)) return new SHA256();\n    BlockHash$2.call(this);\n    this.h = [0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19];\n    this.k = sha256_K;\n    this.W = new Array(64);\n  }\n\n  utils.inherits(SHA256, BlockHash$2);\n  var _256 = SHA256;\n  SHA256.blockSize = 512;\n  SHA256.outSize = 256;\n  SHA256.hmacStrength = 192;\n  SHA256.padLength = 64;\n\n  SHA256.prototype._update = function _update(msg, start) {\n    var W = this.W;\n\n    for (var i = 0; i < 16; i++) W[i] = msg[start + i];\n\n    for (; i < W.length; i++) W[i] = sum32_4$1(g1_256$1(W[i - 2]), W[i - 7], g0_256$1(W[i - 15]), W[i - 16]);\n\n    var a = this.h[0];\n    var b = this.h[1];\n    var c = this.h[2];\n    var d = this.h[3];\n    var e = this.h[4];\n    var f = this.h[5];\n    var g = this.h[6];\n    var h = this.h[7];\n    minimalisticAssert(this.k.length === W.length);\n\n    for (i = 0; i < W.length; i++) {\n      var T1 = sum32_5$2(h, s1_256$1(e), ch32$1(e, f, g), this.k[i], W[i]);\n      var T2 = sum32$2(s0_256$1(a), maj32$1(a, b, c));\n      h = g;\n      g = f;\n      f = e;\n      e = sum32$2(d, T1);\n      d = c;\n      c = b;\n      b = a;\n      a = sum32$2(T1, T2);\n    }\n\n    this.h[0] = sum32$2(this.h[0], a);\n    this.h[1] = sum32$2(this.h[1], b);\n    this.h[2] = sum32$2(this.h[2], c);\n    this.h[3] = sum32$2(this.h[3], d);\n    this.h[4] = sum32$2(this.h[4], e);\n    this.h[5] = sum32$2(this.h[5], f);\n    this.h[6] = sum32$2(this.h[6], g);\n    this.h[7] = sum32$2(this.h[7], h);\n  };\n\n  SHA256.prototype._digest = function digest(enc) {\n    if (enc === 'hex') return utils.toHex32(this.h, 'big');else return utils.split32(this.h, 'big');\n  };\n\n  function SHA224() {\n    if (!(this instanceof SHA224)) return new SHA224();\n\n    _256.call(this);\n\n    this.h = [0xc1059ed8, 0x367cd507, 0x3070dd17, 0xf70e5939, 0xffc00b31, 0x68581511, 0x64f98fa7, 0xbefa4fa4];\n  }\n\n  utils.inherits(SHA224, _256);\n  var _224 = SHA224;\n  SHA224.blockSize = 512;\n  SHA224.outSize = 224;\n  SHA224.hmacStrength = 192;\n  SHA224.padLength = 64;\n\n  SHA224.prototype._digest = function digest(enc) {\n    // Just truncate output\n    if (enc === 'hex') return utils.toHex32(this.h.slice(0, 7), 'big');else return utils.split32(this.h.slice(0, 7), 'big');\n  };\n\n  var rotr64_hi$1 = utils.rotr64_hi;\n  var rotr64_lo$1 = utils.rotr64_lo;\n  var shr64_hi$1 = utils.shr64_hi;\n  var shr64_lo$1 = utils.shr64_lo;\n  var sum64$1 = utils.sum64;\n  var sum64_hi$1 = utils.sum64_hi;\n  var sum64_lo$1 = utils.sum64_lo;\n  var sum64_4_hi$1 = utils.sum64_4_hi;\n  var sum64_4_lo$1 = utils.sum64_4_lo;\n  var sum64_5_hi$1 = utils.sum64_5_hi;\n  var sum64_5_lo$1 = utils.sum64_5_lo;\n  var BlockHash$3 = common.BlockHash;\n  var sha512_K = [0x428a2f98, 0xd728ae22, 0x71374491, 0x23ef65cd, 0xb5c0fbcf, 0xec4d3b2f, 0xe9b5dba5, 0x8189dbbc, 0x3956c25b, 0xf348b538, 0x59f111f1, 0xb605d019, 0x923f82a4, 0xaf194f9b, 0xab1c5ed5, 0xda6d8118, 0xd807aa98, 0xa3030242, 0x12835b01, 0x45706fbe, 0x243185be, 0x4ee4b28c, 0x550c7dc3, 0xd5ffb4e2, 0x72be5d74, 0xf27b896f, 0x80deb1fe, 0x3b1696b1, 0x9bdc06a7, 0x25c71235, 0xc19bf174, 0xcf692694, 0xe49b69c1, 0x9ef14ad2, 0xefbe4786, 0x384f25e3, 0x0fc19dc6, 0x8b8cd5b5, 0x240ca1cc, 0x77ac9c65, 0x2de92c6f, 0x592b0275, 0x4a7484aa, 0x6ea6e483, 0x5cb0a9dc, 0xbd41fbd4, 0x76f988da, 0x831153b5, 0x983e5152, 0xee66dfab, 0xa831c66d, 0x2db43210, 0xb00327c8, 0x98fb213f, 0xbf597fc7, 0xbeef0ee4, 0xc6e00bf3, 0x3da88fc2, 0xd5a79147, 0x930aa725, 0x06ca6351, 0xe003826f, 0x14292967, 0x0a0e6e70, 0x27b70a85, 0x46d22ffc, 0x2e1b2138, 0x5c26c926, 0x4d2c6dfc, 0x5ac42aed, 0x53380d13, 0x9d95b3df, 0x650a7354, 0x8baf63de, 0x766a0abb, 0x3c77b2a8, 0x81c2c92e, 0x47edaee6, 0x92722c85, 0x1482353b, 0xa2bfe8a1, 0x4cf10364, 0xa81a664b, 0xbc423001, 0xc24b8b70, 0xd0f89791, 0xc76c51a3, 0x0654be30, 0xd192e819, 0xd6ef5218, 0xd6990624, 0x5565a910, 0xf40e3585, 0x5771202a, 0x106aa070, 0x32bbd1b8, 0x19a4c116, 0xb8d2d0c8, 0x1e376c08, 0x5141ab53, 0x2748774c, 0xdf8eeb99, 0x34b0bcb5, 0xe19b48a8, 0x391c0cb3, 0xc5c95a63, 0x4ed8aa4a, 0xe3418acb, 0x5b9cca4f, 0x7763e373, 0x682e6ff3, 0xd6b2b8a3, 0x748f82ee, 0x5defb2fc, 0x78a5636f, 0x43172f60, 0x84c87814, 0xa1f0ab72, 0x8cc70208, 0x1a6439ec, 0x90befffa, 0x23631e28, 0xa4506ceb, 0xde82bde9, 0xbef9a3f7, 0xb2c67915, 0xc67178f2, 0xe372532b, 0xca273ece, 0xea26619c, 0xd186b8c7, 0x21c0c207, 0xeada7dd6, 0xcde0eb1e, 0xf57d4f7f, 0xee6ed178, 0x06f067aa, 0x72176fba, 0x0a637dc5, 0xa2c898a6, 0x113f9804, 0xbef90dae, 0x1b710b35, 0x131c471b, 0x28db77f5, 0x23047d84, 0x32caab7b, 0x40c72493, 0x3c9ebe0a, 0x15c9bebc, 0x431d67c4, 0x9c100d4c, 0x4cc5d4be, 0xcb3e42b6, 0x597f299c, 0xfc657e2a, 0x5fcb6fab, 0x3ad6faec, 0x6c44198c, 0x4a475817];\n\n  function SHA512() {\n    if (!(this instanceof SHA512)) return new SHA512();\n    BlockHash$3.call(this);\n    this.h = [0x6a09e667, 0xf3bcc908, 0xbb67ae85, 0x84caa73b, 0x3c6ef372, 0xfe94f82b, 0xa54ff53a, 0x5f1d36f1, 0x510e527f, 0xade682d1, 0x9b05688c, 0x2b3e6c1f, 0x1f83d9ab, 0xfb41bd6b, 0x5be0cd19, 0x137e2179];\n    this.k = sha512_K;\n    this.W = new Array(160);\n  }\n\n  utils.inherits(SHA512, BlockHash$3);\n  var _512 = SHA512;\n  SHA512.blockSize = 1024;\n  SHA512.outSize = 512;\n  SHA512.hmacStrength = 192;\n  SHA512.padLength = 128;\n\n  SHA512.prototype._prepareBlock = function _prepareBlock(msg, start) {\n    var W = this.W; // 32 x 32bit words\n\n    for (var i = 0; i < 32; i++) W[i] = msg[start + i];\n\n    for (; i < W.length; i += 2) {\n      var c0_hi = g1_512_hi(W[i - 4], W[i - 3]); // i - 2\n\n      var c0_lo = g1_512_lo(W[i - 4], W[i - 3]);\n      var c1_hi = W[i - 14]; // i - 7\n\n      var c1_lo = W[i - 13];\n      var c2_hi = g0_512_hi(W[i - 30], W[i - 29]); // i - 15\n\n      var c2_lo = g0_512_lo(W[i - 30], W[i - 29]);\n      var c3_hi = W[i - 32]; // i - 16\n\n      var c3_lo = W[i - 31];\n      W[i] = sum64_4_hi$1(c0_hi, c0_lo, c1_hi, c1_lo, c2_hi, c2_lo, c3_hi, c3_lo);\n      W[i + 1] = sum64_4_lo$1(c0_hi, c0_lo, c1_hi, c1_lo, c2_hi, c2_lo, c3_hi, c3_lo);\n    }\n  };\n\n  SHA512.prototype._update = function _update(msg, start) {\n    this._prepareBlock(msg, start);\n\n    var W = this.W;\n    var ah = this.h[0];\n    var al = this.h[1];\n    var bh = this.h[2];\n    var bl = this.h[3];\n    var ch = this.h[4];\n    var cl = this.h[5];\n    var dh = this.h[6];\n    var dl = this.h[7];\n    var eh = this.h[8];\n    var el = this.h[9];\n    var fh = this.h[10];\n    var fl = this.h[11];\n    var gh = this.h[12];\n    var gl = this.h[13];\n    var hh = this.h[14];\n    var hl = this.h[15];\n    minimalisticAssert(this.k.length === W.length);\n\n    for (var i = 0; i < W.length; i += 2) {\n      var c0_hi = hh;\n      var c0_lo = hl;\n      var c1_hi = s1_512_hi(eh, el);\n      var c1_lo = s1_512_lo(eh, el);\n      var c2_hi = ch64_hi(eh, el, fh, fl, gh, gl);\n      var c2_lo = ch64_lo(eh, el, fh, fl, gh, gl);\n      var c3_hi = this.k[i];\n      var c3_lo = this.k[i + 1];\n      var c4_hi = W[i];\n      var c4_lo = W[i + 1];\n      var T1_hi = sum64_5_hi$1(c0_hi, c0_lo, c1_hi, c1_lo, c2_hi, c2_lo, c3_hi, c3_lo, c4_hi, c4_lo);\n      var T1_lo = sum64_5_lo$1(c0_hi, c0_lo, c1_hi, c1_lo, c2_hi, c2_lo, c3_hi, c3_lo, c4_hi, c4_lo);\n      c0_hi = s0_512_hi(ah, al);\n      c0_lo = s0_512_lo(ah, al);\n      c1_hi = maj64_hi(ah, al, bh, bl, ch, cl);\n      c1_lo = maj64_lo(ah, al, bh, bl, ch, cl);\n      var T2_hi = sum64_hi$1(c0_hi, c0_lo, c1_hi, c1_lo);\n      var T2_lo = sum64_lo$1(c0_hi, c0_lo, c1_hi, c1_lo);\n      hh = gh;\n      hl = gl;\n      gh = fh;\n      gl = fl;\n      fh = eh;\n      fl = el;\n      eh = sum64_hi$1(dh, dl, T1_hi, T1_lo);\n      el = sum64_lo$1(dl, dl, T1_hi, T1_lo);\n      dh = ch;\n      dl = cl;\n      ch = bh;\n      cl = bl;\n      bh = ah;\n      bl = al;\n      ah = sum64_hi$1(T1_hi, T1_lo, T2_hi, T2_lo);\n      al = sum64_lo$1(T1_hi, T1_lo, T2_hi, T2_lo);\n    }\n\n    sum64$1(this.h, 0, ah, al);\n    sum64$1(this.h, 2, bh, bl);\n    sum64$1(this.h, 4, ch, cl);\n    sum64$1(this.h, 6, dh, dl);\n    sum64$1(this.h, 8, eh, el);\n    sum64$1(this.h, 10, fh, fl);\n    sum64$1(this.h, 12, gh, gl);\n    sum64$1(this.h, 14, hh, hl);\n  };\n\n  SHA512.prototype._digest = function digest(enc) {\n    if (enc === 'hex') return utils.toHex32(this.h, 'big');else return utils.split32(this.h, 'big');\n  };\n\n  function ch64_hi(xh, xl, yh, yl, zh) {\n    var r = xh & yh ^ ~xh & zh;\n    if (r < 0) r += 0x100000000;\n    return r;\n  }\n\n  function ch64_lo(xh, xl, yh, yl, zh, zl) {\n    var r = xl & yl ^ ~xl & zl;\n    if (r < 0) r += 0x100000000;\n    return r;\n  }\n\n  function maj64_hi(xh, xl, yh, yl, zh) {\n    var r = xh & yh ^ xh & zh ^ yh & zh;\n    if (r < 0) r += 0x100000000;\n    return r;\n  }\n\n  function maj64_lo(xh, xl, yh, yl, zh, zl) {\n    var r = xl & yl ^ xl & zl ^ yl & zl;\n    if (r < 0) r += 0x100000000;\n    return r;\n  }\n\n  function s0_512_hi(xh, xl) {\n    var c0_hi = rotr64_hi$1(xh, xl, 28);\n    var c1_hi = rotr64_hi$1(xl, xh, 2); // 34\n\n    var c2_hi = rotr64_hi$1(xl, xh, 7); // 39\n\n    var r = c0_hi ^ c1_hi ^ c2_hi;\n    if (r < 0) r += 0x100000000;\n    return r;\n  }\n\n  function s0_512_lo(xh, xl) {\n    var c0_lo = rotr64_lo$1(xh, xl, 28);\n    var c1_lo = rotr64_lo$1(xl, xh, 2); // 34\n\n    var c2_lo = rotr64_lo$1(xl, xh, 7); // 39\n\n    var r = c0_lo ^ c1_lo ^ c2_lo;\n    if (r < 0) r += 0x100000000;\n    return r;\n  }\n\n  function s1_512_hi(xh, xl) {\n    var c0_hi = rotr64_hi$1(xh, xl, 14);\n    var c1_hi = rotr64_hi$1(xh, xl, 18);\n    var c2_hi = rotr64_hi$1(xl, xh, 9); // 41\n\n    var r = c0_hi ^ c1_hi ^ c2_hi;\n    if (r < 0) r += 0x100000000;\n    return r;\n  }\n\n  function s1_512_lo(xh, xl) {\n    var c0_lo = rotr64_lo$1(xh, xl, 14);\n    var c1_lo = rotr64_lo$1(xh, xl, 18);\n    var c2_lo = rotr64_lo$1(xl, xh, 9); // 41\n\n    var r = c0_lo ^ c1_lo ^ c2_lo;\n    if (r < 0) r += 0x100000000;\n    return r;\n  }\n\n  function g0_512_hi(xh, xl) {\n    var c0_hi = rotr64_hi$1(xh, xl, 1);\n    var c1_hi = rotr64_hi$1(xh, xl, 8);\n    var c2_hi = shr64_hi$1(xh, xl, 7);\n    var r = c0_hi ^ c1_hi ^ c2_hi;\n    if (r < 0) r += 0x100000000;\n    return r;\n  }\n\n  function g0_512_lo(xh, xl) {\n    var c0_lo = rotr64_lo$1(xh, xl, 1);\n    var c1_lo = rotr64_lo$1(xh, xl, 8);\n    var c2_lo = shr64_lo$1(xh, xl, 7);\n    var r = c0_lo ^ c1_lo ^ c2_lo;\n    if (r < 0) r += 0x100000000;\n    return r;\n  }\n\n  function g1_512_hi(xh, xl) {\n    var c0_hi = rotr64_hi$1(xh, xl, 19);\n    var c1_hi = rotr64_hi$1(xl, xh, 29); // 61\n\n    var c2_hi = shr64_hi$1(xh, xl, 6);\n    var r = c0_hi ^ c1_hi ^ c2_hi;\n    if (r < 0) r += 0x100000000;\n    return r;\n  }\n\n  function g1_512_lo(xh, xl) {\n    var c0_lo = rotr64_lo$1(xh, xl, 19);\n    var c1_lo = rotr64_lo$1(xl, xh, 29); // 61\n\n    var c2_lo = shr64_lo$1(xh, xl, 6);\n    var r = c0_lo ^ c1_lo ^ c2_lo;\n    if (r < 0) r += 0x100000000;\n    return r;\n  }\n\n  function SHA384() {\n    if (!(this instanceof SHA384)) return new SHA384();\n\n    _512.call(this);\n\n    this.h = [0xcbbb9d5d, 0xc1059ed8, 0x629a292a, 0x367cd507, 0x9159015a, 0x3070dd17, 0x152fecd8, 0xf70e5939, 0x67332667, 0xffc00b31, 0x8eb44a87, 0x68581511, 0xdb0c2e0d, 0x64f98fa7, 0x47b5481d, 0xbefa4fa4];\n  }\n\n  utils.inherits(SHA384, _512);\n  var _384 = SHA384;\n  SHA384.blockSize = 1024;\n  SHA384.outSize = 384;\n  SHA384.hmacStrength = 192;\n  SHA384.padLength = 128;\n\n  SHA384.prototype._digest = function digest(enc) {\n    if (enc === 'hex') return utils.toHex32(this.h.slice(0, 12), 'big');else return utils.split32(this.h.slice(0, 12), 'big');\n  };\n\n  var sha1 = _1;\n  var sha224 = _224;\n  var sha256 = _256;\n  var sha384 = _384;\n  var sha512 = _512;\n  var sha = {\n    sha1: sha1,\n    sha224: sha224,\n    sha256: sha256,\n    sha384: sha384,\n    sha512: sha512\n  };\n  var rotl32$2 = utils.rotl32;\n  var sum32$3 = utils.sum32;\n  var sum32_3$1 = utils.sum32_3;\n  var sum32_4$2 = utils.sum32_4;\n  var BlockHash$4 = common.BlockHash;\n\n  function RIPEMD160() {\n    if (!(this instanceof RIPEMD160)) return new RIPEMD160();\n    BlockHash$4.call(this);\n    this.h = [0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0];\n    this.endian = 'little';\n  }\n\n  utils.inherits(RIPEMD160, BlockHash$4);\n  var ripemd160 = RIPEMD160;\n  RIPEMD160.blockSize = 512;\n  RIPEMD160.outSize = 160;\n  RIPEMD160.hmacStrength = 192;\n  RIPEMD160.padLength = 64;\n\n  RIPEMD160.prototype._update = function update(msg, start) {\n    var A = this.h[0];\n    var B = this.h[1];\n    var C = this.h[2];\n    var D = this.h[3];\n    var E = this.h[4];\n    var Ah = A;\n    var Bh = B;\n    var Ch = C;\n    var Dh = D;\n    var Eh = E;\n\n    for (var j = 0; j < 80; j++) {\n      var T = sum32$3(rotl32$2(sum32_4$2(A, f(j, B, C, D), msg[r[j] + start], K(j)), s[j]), E);\n      A = E;\n      E = D;\n      D = rotl32$2(C, 10);\n      C = B;\n      B = T;\n      T = sum32$3(rotl32$2(sum32_4$2(Ah, f(79 - j, Bh, Ch, Dh), msg[rh[j] + start], Kh(j)), sh[j]), Eh);\n      Ah = Eh;\n      Eh = Dh;\n      Dh = rotl32$2(Ch, 10);\n      Ch = Bh;\n      Bh = T;\n    }\n\n    T = sum32_3$1(this.h[1], C, Dh);\n    this.h[1] = sum32_3$1(this.h[2], D, Eh);\n    this.h[2] = sum32_3$1(this.h[3], E, Ah);\n    this.h[3] = sum32_3$1(this.h[4], A, Bh);\n    this.h[4] = sum32_3$1(this.h[0], B, Ch);\n    this.h[0] = T;\n  };\n\n  RIPEMD160.prototype._digest = function digest(enc) {\n    if (enc === 'hex') return utils.toHex32(this.h, 'little');else return utils.split32(this.h, 'little');\n  };\n\n  function f(j, x, y, z) {\n    if (j <= 15) return x ^ y ^ z;else if (j <= 31) return x & y | ~x & z;else if (j <= 47) return (x | ~y) ^ z;else if (j <= 63) return x & z | y & ~z;else return x ^ (y | ~z);\n  }\n\n  function K(j) {\n    if (j <= 15) return 0x00000000;else if (j <= 31) return 0x5a827999;else if (j <= 47) return 0x6ed9eba1;else if (j <= 63) return 0x8f1bbcdc;else return 0xa953fd4e;\n  }\n\n  function Kh(j) {\n    if (j <= 15) return 0x50a28be6;else if (j <= 31) return 0x5c4dd124;else if (j <= 47) return 0x6d703ef3;else if (j <= 63) return 0x7a6d76e9;else return 0x00000000;\n  }\n\n  var r = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8, 3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12, 1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2, 4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13];\n  var rh = [5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12, 6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2, 15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13, 8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14, 12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11];\n  var s = [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8, 7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12, 11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5, 11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12, 9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6];\n  var sh = [8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6, 9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11, 9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5, 15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8, 8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11];\n  var ripemd = {\n    ripemd160: ripemd160\n  };\n\n  function Hmac(hash, key, enc) {\n    if (!(this instanceof Hmac)) return new Hmac(hash, key, enc);\n    this.Hash = hash;\n    this.blockSize = hash.blockSize / 8;\n    this.outSize = hash.outSize / 8;\n    this.inner = null;\n    this.outer = null;\n\n    this._init(utils.toArray(key, enc));\n  }\n\n  var hmac = Hmac;\n\n  Hmac.prototype._init = function init(key) {\n    // Shorten key, if needed\n    if (key.length > this.blockSize) key = new this.Hash().update(key).digest();\n    minimalisticAssert(key.length <= this.blockSize); // Add padding to key\n\n    for (var i = key.length; i < this.blockSize; i++) key.push(0);\n\n    for (i = 0; i < key.length; i++) key[i] ^= 0x36;\n\n    this.inner = new this.Hash().update(key); // 0x36 ^ 0x5c = 0x6a\n\n    for (i = 0; i < key.length; i++) key[i] ^= 0x6a;\n\n    this.outer = new this.Hash().update(key);\n  };\n\n  Hmac.prototype.update = function update(msg, enc) {\n    this.inner.update(msg, enc);\n    return this;\n  };\n\n  Hmac.prototype.digest = function digest(enc) {\n    this.outer.update(this.inner.digest());\n    return this.outer.digest(enc);\n  };\n\n  var hash_1 = createCommonjsModule(function (module, exports) {\n    var hash = exports;\n    hash.utils = utils;\n    hash.common = common;\n    hash.sha = sha;\n    hash.ripemd = ripemd;\n    hash.hmac = hmac; // Proxy hash functions to the main object\n\n    hash.sha1 = hash.sha.sha1;\n    hash.sha256 = hash.sha.sha256;\n    hash.sha224 = hash.sha.sha224;\n    hash.sha384 = hash.sha.sha384;\n    hash.sha512 = hash.sha.sha512;\n    hash.ripemd160 = hash.ripemd.ripemd160;\n  });\n  /*! *****************************************************************************\r\n  Copyright (c) Microsoft Corporation. All rights reserved.\r\n  Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\n  this file except in compliance with the License. You may obtain a copy of the\r\n  License at http://www.apache.org/licenses/LICENSE-2.0\r\n  \n  THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n  KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\n  WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\n  MERCHANTABLITY OR NON-INFRINGEMENT.\r\n  \n  See the Apache Version 2.0 License for specific language governing permissions\r\n  and limitations under the License.\r\n  ***************************************************************************** */\n\n  var __assign = function () {\n    __assign = Object.assign || function __assign(t) {\n      for (var s, i = 1, n = arguments.length; i < n; i++) {\n        s = arguments[i];\n\n        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n      }\n\n      return t;\n    };\n\n    return __assign.apply(this, arguments);\n  };\n\n  function __decorate(decorators, target, key, desc) {\n    var c = arguments.length,\n        r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n        d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n  }\n\n  function __metadata(metadataKey, metadataValue) {\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\n  }\n\n  function __awaiter(thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n      function fulfilled(value) {\n        try {\n          step(generator.next(value));\n        } catch (e) {\n          reject(e);\n        }\n      }\n\n      function rejected(value) {\n        try {\n          step(generator[\"throw\"](value));\n        } catch (e) {\n          reject(e);\n        }\n      }\n\n      function step(result) {\n        result.done ? resolve(result.value) : new P(function (resolve) {\n          resolve(result.value);\n        }).then(fulfilled, rejected);\n      }\n\n      step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n  }\n\n  function __generator(thisArg, body) {\n    var _ = {\n      label: 0,\n      sent: function () {\n        if (t[0] & 1) throw t[1];\n        return t[1];\n      },\n      trys: [],\n      ops: []\n    },\n        f,\n        y,\n        t,\n        g;\n    return g = {\n      next: verb(0),\n      \"throw\": verb(1),\n      \"return\": verb(2)\n    }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function () {\n      return this;\n    }), g;\n\n    function verb(n) {\n      return function (v) {\n        return step([n, v]);\n      };\n    }\n\n    function step(op) {\n      if (f) throw new TypeError(\"Generator is already executing.\");\n\n      while (_) try {\n        if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n        if (y = 0, t) op = [op[0] & 2, t.value];\n\n        switch (op[0]) {\n          case 0:\n          case 1:\n            t = op;\n            break;\n\n          case 4:\n            _.label++;\n            return {\n              value: op[1],\n              done: false\n            };\n\n          case 5:\n            _.label++;\n            y = op[1];\n            op = [0];\n            continue;\n\n          case 7:\n            op = _.ops.pop();\n\n            _.trys.pop();\n\n            continue;\n\n          default:\n            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n              _ = 0;\n              continue;\n            }\n\n            if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n              _.label = op[1];\n              break;\n            }\n\n            if (op[0] === 6 && _.label < t[1]) {\n              _.label = t[1];\n              t = op;\n              break;\n            }\n\n            if (t && _.label < t[2]) {\n              _.label = t[2];\n\n              _.ops.push(op);\n\n              break;\n            }\n\n            if (t[2]) _.ops.pop();\n\n            _.trys.pop();\n\n            continue;\n        }\n\n        op = body.call(thisArg, _);\n      } catch (e) {\n        op = [6, e];\n        y = 0;\n      } finally {\n        f = t = 0;\n      }\n\n      if (op[0] & 5) throw op[1];\n      return {\n        value: op[0] ? op[1] : void 0,\n        done: true\n      };\n    }\n  } //  This file is part of Zilliqa-Javascript-Library.\n\n\n  var NIL_ADDRESS = '0x0000000000000000000000000000000000000000';\n\n  var Contract =\n  /** @class */\n  function () {\n    function Contract(factory, code, abi, address, init, state) {\n      this.factory = factory;\n      this.provider = factory.provider;\n      this.signer = factory.signer; // assume that we are accessing an existing contract\n\n      if (address) {\n        this.abi = abi;\n        this.address = crypto.normaliseAddress(address);\n        this.init = init;\n        this.state = state;\n        this.status = 0\n        /* Deployed */\n        ;\n      } else {\n        // assume we're deploying\n        this.abi = abi;\n        this.code = code;\n        this.init = init;\n        this.status = 2\n        /* Initialised */\n        ;\n      }\n    }\n    /**\r\n     * isInitialised\r\n     *\r\n     * Returns true if the contract has not been deployed\r\n     *\r\n     * @returns {boolean}\r\n     */\n\n\n    Contract.prototype.isInitialised = function () {\n      return this.status === 2\n      /* Initialised */\n      ;\n    };\n    /**\r\n     * isDeployed\r\n     *\r\n     * Returns true if the contract is deployed\r\n     *\r\n     * @returns {boolean}\r\n     */\n\n\n    Contract.prototype.isDeployed = function () {\n      return this.status === 0\n      /* Deployed */\n      ;\n    };\n    /**\r\n     * isRejected\r\n     *\r\n     * Returns true if an attempt to deploy the contract was made, but the\r\n     * underlying transaction was unsuccessful.\r\n     *\r\n     * @returns {boolean}\r\n     */\n\n\n    Contract.prototype.isRejected = function () {\n      return this.status === 1\n      /* Rejected */\n      ;\n    };\n\n    Contract.prototype.prepareTx = function (tx, attempts, interval, isDeploy) {\n      if (attempts === void 0) {\n        attempts = core.GET_TX_ATTEMPTS;\n      }\n\n      if (interval === void 0) {\n        interval = 1000;\n      }\n\n      return __awaiter(this, void 0, void 0, function () {\n        var response;\n        return __generator(this, function (_a) {\n          switch (_a.label) {\n            case 0:\n              return [4\n              /*yield*/\n              , this.provider.send(\"CreateTransaction\"\n              /* CreateTransaction */\n              , __assign(__assign({}, tx.txParams), {\n                priority: tx.toDS\n              }))];\n\n            case 1:\n              response = _a.sent();\n\n              if (response.error) {\n                this.address = undefined;\n                return [2\n                /*return*/\n                , tx.setStatus(3\n                /* Rejected */\n                )];\n              }\n\n              if (isDeploy) {\n                this.address = response.result.ContractAddress ? crypto.toChecksumAddress(response.result.ContractAddress) : undefined;\n              }\n\n              return [2\n              /*return*/\n              , tx.confirm(response.result.TranID, attempts, interval)];\n          }\n        });\n      });\n    };\n    /**\r\n     * deploy\r\n     *\r\n     * @param {DeployParams} params\r\n     * @returns {Promise<Contract>}\r\n     */\n\n\n    Contract.prototype.deploy = function (params, attempts, interval, toDs) {\n      if (attempts === void 0) {\n        attempts = 33;\n      }\n\n      if (interval === void 0) {\n        interval = 1000;\n      }\n\n      if (toDs === void 0) {\n        toDs = false;\n      }\n\n      return __awaiter(this, void 0, void 0, function () {\n        var tx, err_1;\n        return __generator(this, function (_a) {\n          switch (_a.label) {\n            case 0:\n              if (!this.code || !this.init) {\n                throw new Error('Cannot deploy without code or initialisation parameters.');\n              }\n\n              _a.label = 1;\n\n            case 1:\n              _a.trys.push([1, 3,, 4]);\n\n              return [4\n              /*yield*/\n              , this.prepareTx(new account.Transaction(__assign(__assign({}, params), {\n                toAddr: NIL_ADDRESS,\n                amount: new util.BN(0),\n                code: this.code,\n                data: JSON.stringify(this.init).replace(/\\\\\"/g, '\"')\n              }), this.provider, 0\n              /* Initialised */\n              , toDs), attempts, interval, true)];\n\n            case 2:\n              tx = _a.sent();\n\n              if (tx.isRejected()) {\n                this.status = 1\n                /* Rejected */\n                ;\n                this.address = undefined;\n                return [2\n                /*return*/\n                , [tx, this]];\n              }\n\n              this.status = 0\n              /* Deployed */\n              ;\n              this.address = this.address && crypto.isValidChecksumAddress(this.address) ? this.address : Contracts.getAddressForContract(tx);\n              return [2\n              /*return*/\n              , [tx, this]];\n\n            case 3:\n              err_1 = _a.sent();\n              throw err_1;\n\n            case 4:\n              return [2\n              /*return*/\n              ];\n          }\n        });\n      });\n    };\n    /**\r\n     * call\r\n     *\r\n     * @param {string} transition\r\n     * @param {any} params\r\n     * @returns {Promise<Transaction>}\r\n     */\n\n\n    Contract.prototype.call = function (transition, args, params, attempts, interval, toDs) {\n      if (attempts === void 0) {\n        attempts = 33;\n      }\n\n      if (interval === void 0) {\n        interval = 1000;\n      }\n\n      if (toDs === void 0) {\n        toDs = false;\n      }\n\n      return __awaiter(this, void 0, void 0, function () {\n        var data, err_2;\n        return __generator(this, function (_a) {\n          switch (_a.label) {\n            case 0:\n              data = {\n                _tag: transition,\n                params: args\n              };\n\n              if (!this.address) {\n                return [2\n                /*return*/\n                , Promise.reject('Contract has not been deployed!')];\n              }\n\n              _a.label = 1;\n\n            case 1:\n              _a.trys.push([1, 3,, 4]);\n\n              return [4\n              /*yield*/\n              , this.prepareTx(new account.Transaction(__assign(__assign({}, params), {\n                toAddr: this.address,\n                data: JSON.stringify(data)\n              }), this.provider, 0\n              /* Initialised */\n              , toDs), attempts, interval, false)];\n\n            case 2:\n              return [2\n              /*return*/\n              , _a.sent()];\n\n            case 3:\n              err_2 = _a.sent();\n              throw err_2;\n\n            case 4:\n              return [2\n              /*return*/\n              ];\n          }\n        });\n      });\n    }; // FIXME: Link to @zilliqa-js/blockchain package (reuse code)\n\n\n    Contract.prototype.getState = function () {\n      return __awaiter(this, void 0, void 0, function () {\n        var response;\n        return __generator(this, function (_a) {\n          switch (_a.label) {\n            case 0:\n              if (this.status !== 0\n              /* Deployed */\n              ) {\n                  return [2\n                  /*return*/\n                  , Promise.resolve([])];\n                }\n\n              if (!this.address) {\n                throw new Error('Cannot get state of uninitialised contract');\n              }\n\n              return [4\n              /*yield*/\n              , this.provider.send(\"GetSmartContractState\"\n              /* GetSmartContractState */\n              , this.address.replace('0x', '').toLowerCase())];\n\n            case 1:\n              response = _a.sent();\n              return [2\n              /*return*/\n              , response.result];\n          }\n        });\n      });\n    }; // FIXME: Link to @zilliqa-js/blockchain package (reuse code)\n\n    /**\r\n     * getSubState\r\n     *\r\n     * @param { string } variableName - variable name within the state\r\n     * @param { string[] } indices -  (optional) If the variable is of map type, you can specify an index (or indices)\r\n     * @returns {Promise<RPCResponse<any, string>>}\r\n     */\n\n\n    Contract.prototype.getSubState = function (variableName, indices) {\n      return __awaiter(this, void 0, void 0, function () {\n        var response;\n        return __generator(this, function (_a) {\n          switch (_a.label) {\n            case 0:\n              if (this.status !== 0\n              /* Deployed */\n              ) {\n                  return [2\n                  /*return*/\n                  , Promise.resolve([])];\n                }\n\n              if (!this.address) {\n                throw new Error('Cannot get state of uninitialised contract');\n              }\n\n              if (!variableName) {\n                throw new Error('Variable name required');\n              }\n\n              return [4\n              /*yield*/\n              , this.provider.send(\"GetSmartContractSubState\"\n              /* GetSmartContractSubState */\n              , this.address.replace('0x', '').toLowerCase(), variableName, indices === undefined ? [] : indices)];\n\n            case 1:\n              response = _a.sent();\n              return [2\n              /*return*/\n              , response.result];\n          }\n        });\n      });\n    }; // FIXME: Link to @zilliqa-js/blockchain package (reuse code)\n\n\n    Contract.prototype.getInit = function () {\n      return __awaiter(this, void 0, void 0, function () {\n        var response;\n        return __generator(this, function (_a) {\n          switch (_a.label) {\n            case 0:\n              if (this.status !== 0\n              /* Deployed */\n              ) {\n                  return [2\n                  /*return*/\n                  , Promise.resolve([])];\n                }\n\n              if (!this.address) {\n                throw new Error('Cannot get state of uninitialised contract');\n              }\n\n              return [4\n              /*yield*/\n              , this.provider.send(\"GetSmartContractInit\"\n              /* GetSmartContractInit */\n              , this.address.replace('0x', '').toLowerCase())];\n\n            case 1:\n              response = _a.sent();\n              return [2\n              /*return*/\n              , response.result];\n          }\n        });\n      });\n    };\n\n    __decorate([core.sign, __metadata(\"design:type\", Function), __metadata(\"design:paramtypes\", [account.Transaction, Number, Number, Boolean]), __metadata(\"design:returntype\", Promise)], Contract.prototype, \"prepareTx\", null);\n\n    return Contract;\n  }(); //  This file is part of Zilliqa-Javascript-Library.\n\n  /**\r\n   * Contracts\r\n   *\r\n   * Unlike most zilliqa-js modules, `Contracts` is a factory class.\r\n   * As a result, individual `Contract` instances are instead obtained by\r\n   * calling `Contracts.at` (for an already-deployed contract) and\r\n   * `Contracts.new` (to deploy a new contract).\r\n   */\n\n\n  var Contracts =\n  /** @class */\n  function () {\n    function Contracts(provider, signer) {\n      this.provider = provider;\n      this.provider.middleware.request.use(account.util.formatOutgoingTx, \"CreateTransaction\"\n      /* CreateTransaction */\n      );\n      this.signer = signer;\n    }\n    /**\r\n     * getAddressForContract\r\n     *\r\n     * @static\r\n     * @param {Transaction} tx - transaction used to create the contract\r\n     * @returns {string} - the contract address\r\n     */\n\n\n    Contracts.getAddressForContract = function (tx) {\n      // always subtract 1 from the tx nonce, as contract addresses are computed\n      // based on the nonce in the global state.\n      var nonce = tx.txParams.nonce ? tx.txParams.nonce - 1 : 0;\n      return crypto.toChecksumAddress(hash_1.sha256().update(tx.senderAddress.replace('0x', '').toLowerCase(), 'hex').update(util.bytes.intToHexArray(nonce, 16).join(''), 'hex').digest('hex').slice(24));\n    };\n\n    Contracts.prototype.at = function (address, abi, code, init, state) {\n      return new Contract(this, code, abi, address, init, state);\n    };\n\n    Contracts.prototype.new = function (code, init, abi) {\n      return new Contract(this, code, abi, undefined, init);\n    };\n\n    return Contracts;\n  }(); //  This file is part of Zilliqa-Javascript-Library.\n\n\n  (function (ContractStatus) {\n    ContractStatus[ContractStatus[\"Deployed\"] = 0] = \"Deployed\";\n    ContractStatus[ContractStatus[\"Rejected\"] = 1] = \"Rejected\";\n    ContractStatus[ContractStatus[\"Initialised\"] = 2] = \"Initialised\";\n  })(exports.ContractStatus || (exports.ContractStatus = {})); //  This file is part of Zilliqa-Javascript-Library.\n\n\n  exports.Contracts = Contracts;\n  exports.Contract = Contract;\n  Object.defineProperty(exports, '__esModule', {\n    value: true\n  });\n});","map":null,"metadata":{},"sourceType":"script"}