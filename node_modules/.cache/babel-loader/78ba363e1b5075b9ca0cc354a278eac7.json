{"ast":null,"code":"(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@zilliqa-js/crypto'), require('@zilliqa-js/util'), require('@zilliqa-js/account'), require('@zilliqa-js/core')) : typeof define === 'function' && define.amd ? define(['exports', '@zilliqa-js/crypto', '@zilliqa-js/util', '@zilliqa-js/account', '@zilliqa-js/core'], factory) : factory(global.zjsBlockchain = {}, global.zjsCrypto, global.zjsUtil, global.zjsAccount, global.zjsCore);\n})(this, function (exports, crypto, util, account, core) {\n  'use strict';\n  /*! *****************************************************************************\r\n  Copyright (c) Microsoft Corporation. All rights reserved.\r\n  Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\n  this file except in compliance with the License. You may obtain a copy of the\r\n  License at http://www.apache.org/licenses/LICENSE-2.0\r\n    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n  KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\n  WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\n  MERCHANTABLITY OR NON-INFRINGEMENT.\r\n    See the Apache Version 2.0 License for specific language governing permissions\r\n  and limitations under the License.\r\n  ***************************************************************************** */\n\n  var __assign = function () {\n    __assign = Object.assign || function __assign(t) {\n      for (var s, i = 1, n = arguments.length; i < n; i++) {\n        s = arguments[i];\n\n        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n      }\n\n      return t;\n    };\n\n    return __assign.apply(this, arguments);\n  };\n\n  function __rest(s, e) {\n    var t = {};\n\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n    }\n    return t;\n  }\n\n  function __decorate(decorators, target, key, desc) {\n    var c = arguments.length,\n        r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n        d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n  }\n\n  function __metadata(metadataKey, metadataValue) {\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\n  }\n\n  function __awaiter(thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n      function fulfilled(value) {\n        try {\n          step(generator.next(value));\n        } catch (e) {\n          reject(e);\n        }\n      }\n\n      function rejected(value) {\n        try {\n          step(generator[\"throw\"](value));\n        } catch (e) {\n          reject(e);\n        }\n      }\n\n      function step(result) {\n        result.done ? resolve(result.value) : new P(function (resolve) {\n          resolve(result.value);\n        }).then(fulfilled, rejected);\n      }\n\n      step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n  }\n\n  function __generator(thisArg, body) {\n    var _ = {\n      label: 0,\n      sent: function () {\n        if (t[0] & 1) throw t[1];\n        return t[1];\n      },\n      trys: [],\n      ops: []\n    },\n        f,\n        y,\n        t,\n        g;\n    return g = {\n      next: verb(0),\n      \"throw\": verb(1),\n      \"return\": verb(2)\n    }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function () {\n      return this;\n    }), g;\n\n    function verb(n) {\n      return function (v) {\n        return step([n, v]);\n      };\n    }\n\n    function step(op) {\n      if (f) throw new TypeError(\"Generator is already executing.\");\n\n      while (_) try {\n        if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n        if (y = 0, t) op = [op[0] & 2, t.value];\n\n        switch (op[0]) {\n          case 0:\n          case 1:\n            t = op;\n            break;\n\n          case 4:\n            _.label++;\n            return {\n              value: op[1],\n              done: false\n            };\n\n          case 5:\n            _.label++;\n            y = op[1];\n            op = [0];\n            continue;\n\n          case 7:\n            op = _.ops.pop();\n\n            _.trys.pop();\n\n            continue;\n\n          default:\n            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n              _ = 0;\n              continue;\n            }\n\n            if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n              _.label = op[1];\n              break;\n            }\n\n            if (op[0] === 6 && _.label < t[1]) {\n              _.label = t[1];\n              t = op;\n              break;\n            }\n\n            if (t && _.label < t[2]) {\n              _.label = t[2];\n\n              _.ops.push(op);\n\n              break;\n            }\n\n            if (t[2]) _.ops.pop();\n\n            _.trys.pop();\n\n            continue;\n        }\n\n        op = body.call(thisArg, _);\n      } catch (e) {\n        op = [6, e];\n        y = 0;\n      } finally {\n        f = t = 0;\n      }\n\n      if (op[0] & 5) throw op[1];\n      return {\n        value: op[0] ? op[1] : void 0,\n        done: true\n      };\n    }\n  } //  This file is part of Zilliqa-Javascript-Library.\n\n\n  function toTxParams(response) {\n    var _a = response.result,\n        toAddr = _a.toAddr,\n        senderPubKey = _a.senderPubKey,\n        gasPrice = _a.gasPrice,\n        gasLimit = _a.gasLimit,\n        nonce = _a.nonce,\n        amount = _a.amount,\n        receipt = _a.receipt,\n        version = _a.version,\n        code = _a.code,\n        data = _a.data,\n        rest = __rest(_a, [\"toAddr\", \"senderPubKey\", \"gasPrice\", \"gasLimit\", \"nonce\", \"amount\", \"receipt\", \"version\", \"code\", \"data\"]);\n\n    return __assign(__assign({}, rest), {\n      version: parseInt(version, 10),\n      toAddr: crypto.toChecksumAddress(toAddr),\n      pubKey: senderPubKey.replace('0x', ''),\n      gasPrice: new util.BN(gasPrice),\n      gasLimit: util.Long.fromString(gasLimit, 10),\n      amount: new util.BN(amount),\n      nonce: parseInt(nonce, 10),\n      receipt: __assign(__assign({}, receipt), {\n        cumulative_gas: parseInt(receipt.cumulative_gas, 10)\n      })\n    });\n  } //  This file is part of Zilliqa-Javascript-Library.\n\n\n  var Blockchain =\n  /** @class */\n  function () {\n    function Blockchain(provider, signer) {\n      this.provider = provider;\n      this.provider.middleware.request.use(account.util.formatOutgoingTx, \"CreateTransaction\"\n      /* CreateTransaction */\n      );\n      this.signer = signer;\n    }\n    /**\r\n     * getBlockChainInfo\r\n     *\r\n     * @returns {Promise<RPCResponse<BlockchainInfo, string>>}\r\n     */\n\n\n    Blockchain.prototype.getBlockChainInfo = function () {\n      return this.provider.send(\"GetBlockchainInfo\"\n      /* GetBlockchainInfo */\n      );\n    };\n    /**\r\n     * getShardingStructure\r\n     *\r\n     * @returns {Promise<RPCResponse<ShardingStructure, string>>}\r\n     */\n\n\n    Blockchain.prototype.getShardingStructure = function () {\n      return this.provider.send(\"GetShardingStructure\"\n      /* GetShardingStructure */\n      );\n    };\n    /**\r\n     * getDSBlock\r\n     *\r\n     * Get details of a Directory Service block by block number.\r\n     *\r\n     * @param {number} blockNum\r\n     * @returns {Promise<RPCResponse<DsBlockObj, string>>}\r\n     */\n\n\n    Blockchain.prototype.getDSBlock = function (blockNum) {\n      return this.provider.send(\"GetDsBlock\"\n      /* GetDSBlock */\n      , blockNum.toString());\n    };\n    /**\r\n     * getLatestDSBlock\r\n     *\r\n     * Get details of the most recent Directory Service block.\r\n     *\r\n     * @returns {Promise<RPCResponse<DsBlockObj, string>>}\r\n     */\n\n\n    Blockchain.prototype.getLatestDSBlock = function () {\n      return this.provider.send(\"GetLatestDsBlock\"\n      /* GetLatestDSBlock */\n      );\n    };\n    /**\r\n     * getNumDSBlocks\r\n     *\r\n     * Gets the number of DS blocks that the network has processed.\r\n     *\r\n     * @returns {Promise<RPCResponse<string, string>>}\r\n     */\n\n\n    Blockchain.prototype.getNumDSBlocks = function () {\n      return this.provider.send(\"GetNumDSBlocks\"\n      /* GetNumDSBlocks */\n      );\n    };\n    /**\r\n     * getDSBlockRate\r\n     *\r\n     * Gets the average rate of DS blocks processed per second\r\n     *\r\n     * @returns {Promise<RPCResponse<number, string>>}\r\n     */\n\n\n    Blockchain.prototype.getDSBlockRate = function () {\n      return this.provider.send(\"GetDSBlockRate\"\n      /* GetDSBlockRate */\n      );\n    };\n    /**\r\n     * getDSBlockListing\r\n     *\r\n     * Get a paginated list of Directory Service blocks. Pass in page number as\r\n     * parameter. Returns a maxPages variable that specifies the max number of\r\n     * pages. 1 - latest blocks, maxPages - oldest blocks.\r\n     *\r\n     * @param {number} max\r\n     * @returns {Promise<RPCResponse<BlockList, string>>}\r\n     */\n\n\n    Blockchain.prototype.getDSBlockListing = function (max) {\n      return this.provider.send(\"DSBlockListing\"\n      /* DSBlockListing */\n      , max);\n    };\n    /**\r\n     * getTxBlock\r\n     *\r\n     * Get details of a Transaction block by block number.\r\n     *\r\n     * @param {number} blockNum\r\n     * @returns {Promise<RPCResponse<TxBlockObj, string>>}\r\n     */\n\n\n    Blockchain.prototype.getTxBlock = function (blockNum) {\n      return this.provider.send(\"GetTxBlock\"\n      /* GetTxBlock */\n      , blockNum.toString());\n    };\n    /**\r\n     * getLatestTxBlock\r\n     *\r\n     * Get details of the most recent Transaction block.\r\n     *\r\n     * @returns {Promise<RPCResponse<TxBlockObj, string>>}\r\n     */\n\n\n    Blockchain.prototype.getLatestTxBlock = function () {\n      return this.provider.send(\"GetLatestTxBlock\"\n      /* GetLatestTxBlock */\n      );\n    };\n    /**\r\n     * getNumTxBlocks\r\n     *\r\n     * Gets the total number of TxBlocks.\r\n     *\r\n     * @returns {Promise<RPCResponse<string, string>>}\r\n     */\n\n\n    Blockchain.prototype.getNumTxBlocks = function () {\n      return this.provider.send(\"GetNumTxBlocks\"\n      /* GetNumTxBlocks */\n      );\n    };\n    /**\r\n     * getTxBlockRate\r\n     *\r\n     * Gets the average number of Tx blocks per second.\r\n     *\r\n     * @returns {Promise<RPCResponse<number, string>>}\r\n     */\n\n\n    Blockchain.prototype.getTxBlockRate = function () {\n      return this.provider.send(\"GetTxBlockRate\"\n      /* GetTxBlockRate */\n      );\n    };\n    /**\r\n     * getTxBlockListing\r\n     *\r\n     * Get a paginated list of Transaction blocks. Takes a page number as\r\n     * parameter, where each page contains a list of 10 blocks (max). Returns\r\n     * a maxPages variable that specifies the max number of pages. 1 - latest\r\n     * blocks, maxPages - oldest blocks.\r\n     *\r\n     * @param {number} max\r\n     * @returns {Promise<RPCResponse<BlockList, string>>}\r\n     */\n\n\n    Blockchain.prototype.getTxBlockListing = function (max) {\n      return this.provider.send(\"TxBlockListing\"\n      /* TxBlockListing */\n      , max);\n    };\n    /**\r\n     * getNumTransactions\r\n     *\r\n     * Gets the number of transactions processed by the network so far.\r\n     *\r\n     * @returns {Promise<RPCResponse<string, string>>}\r\n     */\n\n\n    Blockchain.prototype.getNumTransactions = function () {\n      return this.provider.send(\"GetNumTransactions\"\n      /* GetNumTransactions */\n      );\n    };\n    /**\r\n     * getTransactionRate\r\n     *\r\n     * Gets the number of transactions processed per second\r\n     *\r\n     * @returns {Promise<RPCResponse<number, string>>}\r\n     */\n\n\n    Blockchain.prototype.getTransactionRate = function () {\n      return this.provider.send(\"GetTransactionRate\"\n      /* GetTransactionRate */\n      );\n    };\n    /**\r\n     * getCurrentMiniEpoch\r\n     *\r\n     * Gets the current Tx Epoch.\r\n     *\r\n     * @returns {Promise<RPCResponse<string, string>>}\r\n     */\n\n\n    Blockchain.prototype.getCurrentMiniEpoch = function () {\n      return this.provider.send(\"GetCurrentMiniEpoch\"\n      /* GetCurrentMiniEpoch */\n      );\n    };\n    /**\r\n     * getCurrentDSEpoch\r\n     *\r\n     * Gets the current DS Epoch.\r\n     *\r\n     * @returns {Promise<RPCResponse<any, string>>}\r\n     */\n\n\n    Blockchain.prototype.getCurrentDSEpoch = function () {\n      return this.provider.send(\"GetCurrentDSEpoch\"\n      /* GetCurrentDSEpoch */\n      );\n    };\n    /**\r\n     * getPrevDifficulty\r\n     *\r\n     * Gets shard difficulty for previous PoW round\r\n     *\r\n     * @returns {Promise<RPCResponse<number, string>>}\r\n     */\n\n\n    Blockchain.prototype.getPrevDifficulty = function () {\n      return this.provider.send(\"GetPrevDifficulty\"\n      /* GetPrevDifficulty */\n      );\n    };\n    /**\r\n     * getPrevDSDifficulty\r\n     *\r\n     * Gets DS difficulty for previous PoW round\r\n     *\r\n     * @returns {Promise<RPCResponse<number, string>>}\r\n     */\n\n\n    Blockchain.prototype.getPrevDSDifficulty = function () {\n      return this.provider.send(\"GetPrevDSDifficulty\"\n      /* GetPrevDSDifficulty */\n      );\n    };\n    /**\r\n     * createTransaction\r\n     *\r\n     * Creates a transaction and polls the lookup node for a transaction\r\n     * receipt. The transaction is considered to be lost if it is not confirmed\r\n     * within the timeout period.\r\n     *\r\n     * @param {Transaction} tx\r\n     * @param {number} maxAttempts - (optional) number of times to poll before timing out\r\n     * @param {number} number - (optional) interval in ms\r\n     * @returns {Promise<Transaction>} - the Transaction that has been signed and\r\n     * broadcasted to the network.\r\n     */\n\n\n    Blockchain.prototype.createTransaction = function (tx, maxAttempts, interval, blockConfirm) {\n      if (maxAttempts === void 0) {\n        maxAttempts = core.GET_TX_ATTEMPTS;\n      }\n\n      if (interval === void 0) {\n        interval = 1000;\n      }\n\n      if (blockConfirm === void 0) {\n        blockConfirm = false;\n      }\n\n      return __awaiter(this, void 0, void 0, function () {\n        var response, err_1;\n        return __generator(this, function (_a) {\n          switch (_a.label) {\n            case 0:\n              _a.trys.push([0, 2,, 3]);\n\n              return [4\n              /*yield*/\n              , this.provider.send(\"CreateTransaction\"\n              /* CreateTransaction */\n              , __assign(__assign({}, tx.txParams), {\n                priority: tx.toDS\n              }))];\n\n            case 1:\n              response = _a.sent();\n\n              if (response.error) {\n                throw response.error;\n              }\n\n              if (blockConfirm) {\n                return [2\n                /*return*/\n                , tx.blockConfirm(response.result.TranID, maxAttempts, interval)];\n              }\n\n              return [2\n              /*return*/\n              , tx.confirm(response.result.TranID, maxAttempts, interval)];\n\n            case 2:\n              err_1 = _a.sent();\n              throw err_1;\n\n            case 3:\n              return [2\n              /*return*/\n              ];\n          }\n        });\n      });\n    };\n    /**\r\n     * getTransaction\r\n     *\r\n     * Retrieves a transaction from the blockchain by its hash. If the result\r\n     * contains an Error, a rejected Promise is returned with the erorr message.\r\n     * If it does not contained an error, but `receipt.success` is `false`, then\r\n     * a rejected Transaction instance is returned.\r\n     *\r\n     * @param {string} txHash\r\n     * @returns {Promise<any>}\r\n     */\n\n\n    Blockchain.prototype.getTransaction = function (txHash) {\n      return __awaiter(this, void 0, void 0, function () {\n        var response, err_2;\n        return __generator(this, function (_a) {\n          switch (_a.label) {\n            case 0:\n              _a.trys.push([0, 2,, 3]);\n\n              return [4\n              /*yield*/\n              , this.provider.send(\"GetTransaction\"\n              /* GetTransaction */\n              , txHash)];\n\n            case 1:\n              response = _a.sent();\n\n              if (response.error) {\n                return [2\n                /*return*/\n                , Promise.reject(response.error)];\n              }\n\n              return [2\n              /*return*/\n              , response.result.receipt.success ? account.Transaction.confirm(toTxParams(response), this.provider) : account.Transaction.reject(toTxParams(response), this.provider)];\n\n            case 2:\n              err_2 = _a.sent();\n              throw err_2;\n\n            case 3:\n              return [2\n              /*return*/\n              ];\n          }\n        });\n      });\n    };\n    /**\r\n     * getRecentTransactions\r\n     *\r\n     * Gets a list of recent transactions\r\n     *\r\n     * @returns {Promise<RPCResponse<TxList, never>>}\r\n     */\n\n\n    Blockchain.prototype.getRecentTransactions = function () {\n      return this.provider.send(\"GetRecentTransactions\"\n      /* GetRecentTransactions */\n      );\n    };\n    /**\r\n     * getTransactionsForTxBlock\r\n     *\r\n     * Gets all transactions for a given TxBlock, grouped by shard id\r\n     *\r\n     * @param {number} txBlock\r\n     * @returns {Promise<RPCResponse<string[][], string>>}\r\n     */\n\n\n    Blockchain.prototype.getTransactionsForTxBlock = function (txBlock) {\n      return this.provider.send(\"GetTransactionsForTxBlock\"\n      /* GetTransactionsForTxBlock */\n      , txBlock.toString());\n    };\n    /**\r\n     * getNumTxnsTxEpoch\r\n     *\r\n     * Gets the number of transactions procesed for a given Tx Epoch.\r\n     *\r\n     * @param {number} epoch\r\n     * @returns {Promise<RPCResponse<number, never>>}\r\n     */\n\n\n    Blockchain.prototype.getNumTxnsTxEpoch = function (epoch) {\n      return this.provider.send(\"GetNumTxnsTxEpoch\"\n      /* GetNumTxnsTxEpoch */\n      , epoch);\n    };\n    /**\r\n     * getNumTxnsDSEpoch\r\n     *\r\n     * Gets the number of transactions procesed for a given DS Epoch.\r\n     *\r\n     * @param {number} epoch\r\n     * @returns {Promise<any>}\r\n     */\n\n\n    Blockchain.prototype.getNumTxnsDSEpoch = function (epoch) {\n      return this.provider.send(\"GetNumTxnsDSEpoch\"\n      /* GetNumTxnsDSEpoch */\n      , epoch);\n    };\n    /**\r\n     * getMinimumGasPrice\r\n     *\r\n     * Gets the numeric minimum gas price\r\n     *\r\n     * @returns {Promise<RPCResponse<string, string>>}\r\n     */\n\n\n    Blockchain.prototype.getMinimumGasPrice = function () {\n      return this.provider.send(\"GetMinimumGasPrice\"\n      /* GetMinimumGasPrice */\n      );\n    };\n    /**\r\n     * getBalance\r\n     *\r\n     * Gets the balance of an account by address\r\n     *\r\n     * @param {string} address\r\n     * @returns {Promise<RPCResponse<any, string>>}\r\n     */\n\n\n    Blockchain.prototype.getBalance = function (addr) {\n      var address = util.validation.isBech32(addr) ? crypto.fromBech32Address(addr) : addr;\n      return this.provider.send(\"GetBalance\"\n      /* GetBalance */\n      , address.replace('0x', '').toLowerCase());\n    };\n    /**\r\n     * getSmartContractCode - returns the smart contract code of a deployed contract.\r\n     *\r\n     * @param {string} address\r\n     * @returns {Promise<RPCResponse<{code: string }, string>>}\r\n     */\n\n\n    Blockchain.prototype.getSmartContractCode = function (addr) {\n      var address = util.validation.isBech32(addr) ? crypto.fromBech32Address(addr) : addr;\n      return this.provider.send(\"GetSmartContractCode\"\n      /* GetSmartContractCode */\n      , address.replace('0x', '').toLowerCase());\n    };\n    /**\r\n     * getSmartContractInit\r\n     *\r\n     * @param {string} address\r\n     * @returns {Promise<RPCResponse<Value[], string>>}\r\n     */\n\n\n    Blockchain.prototype.getSmartContractInit = function (addr) {\n      var address = util.validation.isBech32(addr) ? crypto.fromBech32Address(addr) : addr;\n      return this.provider.send(\"GetSmartContractInit\"\n      /* GetSmartContractInit */\n      , address.replace('0x', '').toLowerCase());\n    };\n    /**\r\n     * getSmartContractState - retrieves the entire state of a smart contract\r\n     *\r\n     * @param {string} address\r\n     * @returns {Promise<RPCResponse<any, string>>}\r\n     */\n\n\n    Blockchain.prototype.getSmartContractState = function (addr) {\n      var address = util.validation.isBech32(addr) ? crypto.fromBech32Address(addr) : addr;\n      return this.provider.send(\"GetSmartContractState\"\n      /* GetSmartContractState */\n      , address.replace('0x', '').toLowerCase());\n    };\n    /**\r\n     * getSmartContractSubState - Queries the contract state, filtered by the variable names.\r\n     * This function is the filtered version of `getSmartContractState`.\r\n     * As `getSubState` performs the filtering, `variableName` of a field is required.\r\n     * If the `subState` is not found, this returns a `null` response.\r\n     *\r\n     * @param {string} address\r\n     * @param { string } variableName - variable name within the state\r\n     * @param { string[] } indices - (optional) If the variable is of map type, you can specify an index (or indices)\r\n     * @returns {Promise<RPCResponse<any, string>>}\r\n     */\n\n\n    Blockchain.prototype.getSmartContractSubState = function (addr, variableName, indices) {\n      var address = util.validation.isBech32(addr) ? crypto.fromBech32Address(addr) : addr;\n\n      if (!variableName) {\n        throw new Error('Variable name required');\n      }\n\n      return this.provider.send(\"GetSmartContractSubState\"\n      /* GetSmartContractSubState */\n      , address.replace('0x', '').toLowerCase(), variableName, indices === undefined ? [] : indices);\n    };\n    /**\r\n     * getSmartContracts\r\n     *\r\n     * @param {string} address\r\n     * @returns {Promise<RPCResponse<Omit<ContractObj, 'init' | 'abi'>, string>>}\r\n     */\n\n\n    Blockchain.prototype.getSmartContracts = function (addr) {\n      var address = util.validation.isBech32(addr) ? crypto.fromBech32Address(addr) : addr;\n      return this.provider.send(\"GetSmartContracts\"\n      /* GetSmartContracts */\n      , address.replace('0x', '').toLowerCase());\n    };\n    /**\r\n     * getContractAddressFromTransactionID\r\n     *\r\n     * @param {string} txHash\r\n     * @returns {Promise<RPCResponse<string, string>>}\r\n     */\n\n\n    Blockchain.prototype.getContractAddressFromTransactionID = function (txHash) {\n      return this.provider.send(\"GetContractAddressFromTransactionID\"\n      /* GetContractAddressFromTransactionID */\n      , txHash);\n    };\n\n    __decorate([core.sign, __metadata(\"design:type\", Function), __metadata(\"design:paramtypes\", [account.Transaction, Number, Number, Boolean]), __metadata(\"design:returntype\", Promise)], Blockchain.prototype, \"createTransaction\", null);\n\n    return Blockchain;\n  }(); //  This file is part of Zilliqa-Javascript-Library.\n  //\n  //  This program is free software: you can redistribute it and/or modify\n  //  it under the terms of the GNU General Public License as published by\n  //  the Free Software Foundation, either version 3 of the License, or\n  //  (at your option) any later version.\n  //\n  //   This program is distributed in the hope that it will be useful,\n  //   but WITHOUT ANY WARRANTY; without even the implied warranty of\n  //   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n  //   GNU General Public License for more details.\n  //\n  //   You should have received a copy of the GNU General Public License\n  //   along with this program.  If not, see <https://www.gnu.org/licenses/>.\n\n\n  var NetworkMethods;\n\n  (function (NetworkMethods) {\n    NetworkMethods[\"GetClientVersion\"] = \"GetClientVersion\";\n    NetworkMethods[\"GetNetworkId\"] = \"GetNetworkId\";\n    NetworkMethods[\"GetProtocolVersion\"] = \"GetProtocolVersion\";\n  })(NetworkMethods || (NetworkMethods = {}));\n\n  var Network =\n  /** @class */\n  function () {\n    function Network(provider, signer) {\n      this.provider = provider;\n      this.signer = signer;\n    }\n\n    Network.prototype.getClientVersion = function () {\n      return this.provider.send(\"GetClientVersion\"\n      /* GetClientVersion */\n      );\n    };\n\n    Network.prototype.GetNetworkId = function () {\n      return this.provider.send(\"GetNetworkId\"\n      /* GetNetworkId */\n      );\n    };\n\n    Network.prototype.GetProtocolVersion = function (blockNum) {\n      return this.provider.send(\"GetProtocolVersion\"\n      /* GetProtocolVersion */\n      );\n    };\n\n    return Network;\n  }(); //  This file is part of Zilliqa-Javascript-Library.\n\n\n  exports.Blockchain = Blockchain;\n  exports.Network = Network;\n  Object.defineProperty(exports, '__esModule', {\n    value: true\n  });\n});","map":null,"metadata":{},"sourceType":"script"}