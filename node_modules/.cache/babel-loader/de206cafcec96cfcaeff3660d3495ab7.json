{"ast":null,"code":"/*eslint-disable block-scoped-var, id-length, no-control-regex, no-magic-numbers, no-prototype-builtins, no-redeclare, no-shadow, no-var, sort-vars*/\n\"use strict\";\n\nvar $protobuf = require(\"protobufjs/minimal\"); // Common aliases\n\n\nvar $Reader = $protobuf.Reader,\n    $Writer = $protobuf.Writer,\n    $util = $protobuf.util; // Exported root namespace\n\nvar $root = $protobuf.roots[\"default\"] || ($protobuf.roots[\"default\"] = {});\n\n$root.ZilliqaMessage = function () {\n  /**\n   * Namespace ZilliqaMessage.\n   * @exports ZilliqaMessage\n   * @namespace\n   */\n  var ZilliqaMessage = {};\n\n  ZilliqaMessage.ByteArray = function () {\n    /**\n     * Properties of a ByteArray.\n     * @memberof ZilliqaMessage\n     * @interface IByteArray\n     * @property {Uint8Array} data ByteArray data\n     */\n\n    /**\n     * Constructs a new ByteArray.\n     * @memberof ZilliqaMessage\n     * @classdesc Represents a ByteArray.\n     * @implements IByteArray\n     * @constructor\n     * @param {ZilliqaMessage.IByteArray=} [properties] Properties to set\n     */\n    function ByteArray(properties) {\n      if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * ByteArray data.\n     * @member {Uint8Array} data\n     * @memberof ZilliqaMessage.ByteArray\n     * @instance\n     */\n\n\n    ByteArray.prototype.data = $util.newBuffer([]);\n    /**\n     * Creates a new ByteArray instance using the specified properties.\n     * @function create\n     * @memberof ZilliqaMessage.ByteArray\n     * @static\n     * @param {ZilliqaMessage.IByteArray=} [properties] Properties to set\n     * @returns {ZilliqaMessage.ByteArray} ByteArray instance\n     */\n\n    ByteArray.create = function create(properties) {\n      return new ByteArray(properties);\n    };\n    /**\n     * Encodes the specified ByteArray message. Does not implicitly {@link ZilliqaMessage.ByteArray.verify|verify} messages.\n     * @function encode\n     * @memberof ZilliqaMessage.ByteArray\n     * @static\n     * @param {ZilliqaMessage.IByteArray} message ByteArray message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n\n\n    ByteArray.encode = function encode(message, writer) {\n      if (!writer) writer = $Writer.create();\n      writer.uint32(\n      /* id 1, wireType 2 =*/\n      10).bytes(message.data);\n      return writer;\n    };\n    /**\n     * Encodes the specified ByteArray message, length delimited. Does not implicitly {@link ZilliqaMessage.ByteArray.verify|verify} messages.\n     * @function encodeDelimited\n     * @memberof ZilliqaMessage.ByteArray\n     * @static\n     * @param {ZilliqaMessage.IByteArray} message ByteArray message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n\n\n    ByteArray.encodeDelimited = function encodeDelimited(message, writer) {\n      return this.encode(message, writer).ldelim();\n    };\n    /**\n     * Decodes a ByteArray message from the specified reader or buffer.\n     * @function decode\n     * @memberof ZilliqaMessage.ByteArray\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {ZilliqaMessage.ByteArray} ByteArray\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n\n\n    ByteArray.decode = function decode(reader, length) {\n      if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n      var end = length === undefined ? reader.len : reader.pos + length,\n          message = new $root.ZilliqaMessage.ByteArray();\n\n      while (reader.pos < end) {\n        var tag = reader.uint32();\n\n        switch (tag >>> 3) {\n          case 1:\n            message.data = reader.bytes();\n            break;\n\n          default:\n            reader.skipType(tag & 7);\n            break;\n        }\n      }\n\n      if (!message.hasOwnProperty(\"data\")) throw $util.ProtocolError(\"missing required 'data'\", {\n        instance: message\n      });\n      return message;\n    };\n    /**\n     * Decodes a ByteArray message from the specified reader or buffer, length delimited.\n     * @function decodeDelimited\n     * @memberof ZilliqaMessage.ByteArray\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @returns {ZilliqaMessage.ByteArray} ByteArray\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n\n\n    ByteArray.decodeDelimited = function decodeDelimited(reader) {\n      if (!(reader instanceof $Reader)) reader = new $Reader(reader);\n      return this.decode(reader, reader.uint32());\n    };\n    /**\n     * Verifies a ByteArray message.\n     * @function verify\n     * @memberof ZilliqaMessage.ByteArray\n     * @static\n     * @param {Object.<string,*>} message Plain object to verify\n     * @returns {string|null} `null` if valid, otherwise the reason why it is not\n     */\n\n\n    ByteArray.verify = function verify(message) {\n      if (typeof message !== \"object\" || message === null) return \"object expected\";\n      if (!(message.data && typeof message.data.length === \"number\" || $util.isString(message.data))) return \"data: buffer expected\";\n      return null;\n    };\n    /**\n     * Creates a ByteArray message from a plain object. Also converts values to their respective internal types.\n     * @function fromObject\n     * @memberof ZilliqaMessage.ByteArray\n     * @static\n     * @param {Object.<string,*>} object Plain object\n     * @returns {ZilliqaMessage.ByteArray} ByteArray\n     */\n\n\n    ByteArray.fromObject = function fromObject(object) {\n      if (object instanceof $root.ZilliqaMessage.ByteArray) return object;\n      var message = new $root.ZilliqaMessage.ByteArray();\n      if (object.data != null) if (typeof object.data === \"string\") $util.base64.decode(object.data, message.data = $util.newBuffer($util.base64.length(object.data)), 0);else if (object.data.length) message.data = object.data;\n      return message;\n    };\n    /**\n     * Creates a plain object from a ByteArray message. Also converts values to other types if specified.\n     * @function toObject\n     * @memberof ZilliqaMessage.ByteArray\n     * @static\n     * @param {ZilliqaMessage.ByteArray} message ByteArray\n     * @param {$protobuf.IConversionOptions} [options] Conversion options\n     * @returns {Object.<string,*>} Plain object\n     */\n\n\n    ByteArray.toObject = function toObject(message, options) {\n      if (!options) options = {};\n      var object = {};\n      if (options.defaults) if (options.bytes === String) object.data = \"\";else {\n        object.data = [];\n        if (options.bytes !== Array) object.data = $util.newBuffer(object.data);\n      }\n      if (message.data != null && message.hasOwnProperty(\"data\")) object.data = options.bytes === String ? $util.base64.encode(message.data, 0, message.data.length) : options.bytes === Array ? Array.prototype.slice.call(message.data) : message.data;\n      return object;\n    };\n    /**\n     * Converts this ByteArray to JSON.\n     * @function toJSON\n     * @memberof ZilliqaMessage.ByteArray\n     * @instance\n     * @returns {Object.<string,*>} JSON object\n     */\n\n\n    ByteArray.prototype.toJSON = function toJSON() {\n      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n    };\n\n    return ByteArray;\n  }();\n\n  ZilliqaMessage.ProtoTransactionCoreInfo = function () {\n    /**\n     * Properties of a ProtoTransactionCoreInfo.\n     * @memberof ZilliqaMessage\n     * @interface IProtoTransactionCoreInfo\n     * @property {number|null} [version] ProtoTransactionCoreInfo version\n     * @property {number|Long|null} [nonce] ProtoTransactionCoreInfo nonce\n     * @property {Uint8Array|null} [toaddr] ProtoTransactionCoreInfo toaddr\n     * @property {ZilliqaMessage.IByteArray|null} [senderpubkey] ProtoTransactionCoreInfo senderpubkey\n     * @property {ZilliqaMessage.IByteArray|null} [amount] ProtoTransactionCoreInfo amount\n     * @property {ZilliqaMessage.IByteArray|null} [gasprice] ProtoTransactionCoreInfo gasprice\n     * @property {number|Long|null} [gaslimit] ProtoTransactionCoreInfo gaslimit\n     * @property {Uint8Array|null} [code] ProtoTransactionCoreInfo code\n     * @property {Uint8Array|null} [data] ProtoTransactionCoreInfo data\n     */\n\n    /**\n     * Constructs a new ProtoTransactionCoreInfo.\n     * @memberof ZilliqaMessage\n     * @classdesc Represents a ProtoTransactionCoreInfo.\n     * @implements IProtoTransactionCoreInfo\n     * @constructor\n     * @param {ZilliqaMessage.IProtoTransactionCoreInfo=} [properties] Properties to set\n     */\n    function ProtoTransactionCoreInfo(properties) {\n      if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * ProtoTransactionCoreInfo version.\n     * @member {number} version\n     * @memberof ZilliqaMessage.ProtoTransactionCoreInfo\n     * @instance\n     */\n\n\n    ProtoTransactionCoreInfo.prototype.version = 0;\n    /**\n     * ProtoTransactionCoreInfo nonce.\n     * @member {number|Long} nonce\n     * @memberof ZilliqaMessage.ProtoTransactionCoreInfo\n     * @instance\n     */\n\n    ProtoTransactionCoreInfo.prototype.nonce = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;\n    /**\n     * ProtoTransactionCoreInfo toaddr.\n     * @member {Uint8Array} toaddr\n     * @memberof ZilliqaMessage.ProtoTransactionCoreInfo\n     * @instance\n     */\n\n    ProtoTransactionCoreInfo.prototype.toaddr = $util.newBuffer([]);\n    /**\n     * ProtoTransactionCoreInfo senderpubkey.\n     * @member {ZilliqaMessage.IByteArray|null|undefined} senderpubkey\n     * @memberof ZilliqaMessage.ProtoTransactionCoreInfo\n     * @instance\n     */\n\n    ProtoTransactionCoreInfo.prototype.senderpubkey = null;\n    /**\n     * ProtoTransactionCoreInfo amount.\n     * @member {ZilliqaMessage.IByteArray|null|undefined} amount\n     * @memberof ZilliqaMessage.ProtoTransactionCoreInfo\n     * @instance\n     */\n\n    ProtoTransactionCoreInfo.prototype.amount = null;\n    /**\n     * ProtoTransactionCoreInfo gasprice.\n     * @member {ZilliqaMessage.IByteArray|null|undefined} gasprice\n     * @memberof ZilliqaMessage.ProtoTransactionCoreInfo\n     * @instance\n     */\n\n    ProtoTransactionCoreInfo.prototype.gasprice = null;\n    /**\n     * ProtoTransactionCoreInfo gaslimit.\n     * @member {number|Long} gaslimit\n     * @memberof ZilliqaMessage.ProtoTransactionCoreInfo\n     * @instance\n     */\n\n    ProtoTransactionCoreInfo.prototype.gaslimit = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;\n    /**\n     * ProtoTransactionCoreInfo code.\n     * @member {Uint8Array} code\n     * @memberof ZilliqaMessage.ProtoTransactionCoreInfo\n     * @instance\n     */\n\n    ProtoTransactionCoreInfo.prototype.code = $util.newBuffer([]);\n    /**\n     * ProtoTransactionCoreInfo data.\n     * @member {Uint8Array} data\n     * @memberof ZilliqaMessage.ProtoTransactionCoreInfo\n     * @instance\n     */\n\n    ProtoTransactionCoreInfo.prototype.data = $util.newBuffer([]);\n    /**\n     * Creates a new ProtoTransactionCoreInfo instance using the specified properties.\n     * @function create\n     * @memberof ZilliqaMessage.ProtoTransactionCoreInfo\n     * @static\n     * @param {ZilliqaMessage.IProtoTransactionCoreInfo=} [properties] Properties to set\n     * @returns {ZilliqaMessage.ProtoTransactionCoreInfo} ProtoTransactionCoreInfo instance\n     */\n\n    ProtoTransactionCoreInfo.create = function create(properties) {\n      return new ProtoTransactionCoreInfo(properties);\n    };\n    /**\n     * Encodes the specified ProtoTransactionCoreInfo message. Does not implicitly {@link ZilliqaMessage.ProtoTransactionCoreInfo.verify|verify} messages.\n     * @function encode\n     * @memberof ZilliqaMessage.ProtoTransactionCoreInfo\n     * @static\n     * @param {ZilliqaMessage.IProtoTransactionCoreInfo} message ProtoTransactionCoreInfo message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n\n\n    ProtoTransactionCoreInfo.encode = function encode(message, writer) {\n      if (!writer) writer = $Writer.create();\n      if (message.version != null && message.hasOwnProperty(\"version\")) writer.uint32(\n      /* id 1, wireType 0 =*/\n      8).uint32(message.version);\n      if (message.nonce != null && message.hasOwnProperty(\"nonce\")) writer.uint32(\n      /* id 2, wireType 0 =*/\n      16).uint64(message.nonce);\n      if (message.toaddr != null && message.hasOwnProperty(\"toaddr\")) writer.uint32(\n      /* id 3, wireType 2 =*/\n      26).bytes(message.toaddr);\n      if (message.senderpubkey != null && message.hasOwnProperty(\"senderpubkey\")) $root.ZilliqaMessage.ByteArray.encode(message.senderpubkey, writer.uint32(\n      /* id 4, wireType 2 =*/\n      34).fork()).ldelim();\n      if (message.amount != null && message.hasOwnProperty(\"amount\")) $root.ZilliqaMessage.ByteArray.encode(message.amount, writer.uint32(\n      /* id 5, wireType 2 =*/\n      42).fork()).ldelim();\n      if (message.gasprice != null && message.hasOwnProperty(\"gasprice\")) $root.ZilliqaMessage.ByteArray.encode(message.gasprice, writer.uint32(\n      /* id 6, wireType 2 =*/\n      50).fork()).ldelim();\n      if (message.gaslimit != null && message.hasOwnProperty(\"gaslimit\")) writer.uint32(\n      /* id 7, wireType 0 =*/\n      56).uint64(message.gaslimit);\n      if (message.code != null && message.hasOwnProperty(\"code\")) writer.uint32(\n      /* id 8, wireType 2 =*/\n      66).bytes(message.code);\n      if (message.data != null && message.hasOwnProperty(\"data\")) writer.uint32(\n      /* id 9, wireType 2 =*/\n      74).bytes(message.data);\n      return writer;\n    };\n    /**\n     * Encodes the specified ProtoTransactionCoreInfo message, length delimited. Does not implicitly {@link ZilliqaMessage.ProtoTransactionCoreInfo.verify|verify} messages.\n     * @function encodeDelimited\n     * @memberof ZilliqaMessage.ProtoTransactionCoreInfo\n     * @static\n     * @param {ZilliqaMessage.IProtoTransactionCoreInfo} message ProtoTransactionCoreInfo message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n\n\n    ProtoTransactionCoreInfo.encodeDelimited = function encodeDelimited(message, writer) {\n      return this.encode(message, writer).ldelim();\n    };\n    /**\n     * Decodes a ProtoTransactionCoreInfo message from the specified reader or buffer.\n     * @function decode\n     * @memberof ZilliqaMessage.ProtoTransactionCoreInfo\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {ZilliqaMessage.ProtoTransactionCoreInfo} ProtoTransactionCoreInfo\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n\n\n    ProtoTransactionCoreInfo.decode = function decode(reader, length) {\n      if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n      var end = length === undefined ? reader.len : reader.pos + length,\n          message = new $root.ZilliqaMessage.ProtoTransactionCoreInfo();\n\n      while (reader.pos < end) {\n        var tag = reader.uint32();\n\n        switch (tag >>> 3) {\n          case 1:\n            message.version = reader.uint32();\n            break;\n\n          case 2:\n            message.nonce = reader.uint64();\n            break;\n\n          case 3:\n            message.toaddr = reader.bytes();\n            break;\n\n          case 4:\n            message.senderpubkey = $root.ZilliqaMessage.ByteArray.decode(reader, reader.uint32());\n            break;\n\n          case 5:\n            message.amount = $root.ZilliqaMessage.ByteArray.decode(reader, reader.uint32());\n            break;\n\n          case 6:\n            message.gasprice = $root.ZilliqaMessage.ByteArray.decode(reader, reader.uint32());\n            break;\n\n          case 7:\n            message.gaslimit = reader.uint64();\n            break;\n\n          case 8:\n            message.code = reader.bytes();\n            break;\n\n          case 9:\n            message.data = reader.bytes();\n            break;\n\n          default:\n            reader.skipType(tag & 7);\n            break;\n        }\n      }\n\n      return message;\n    };\n    /**\n     * Decodes a ProtoTransactionCoreInfo message from the specified reader or buffer, length delimited.\n     * @function decodeDelimited\n     * @memberof ZilliqaMessage.ProtoTransactionCoreInfo\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @returns {ZilliqaMessage.ProtoTransactionCoreInfo} ProtoTransactionCoreInfo\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n\n\n    ProtoTransactionCoreInfo.decodeDelimited = function decodeDelimited(reader) {\n      if (!(reader instanceof $Reader)) reader = new $Reader(reader);\n      return this.decode(reader, reader.uint32());\n    };\n    /**\n     * Verifies a ProtoTransactionCoreInfo message.\n     * @function verify\n     * @memberof ZilliqaMessage.ProtoTransactionCoreInfo\n     * @static\n     * @param {Object.<string,*>} message Plain object to verify\n     * @returns {string|null} `null` if valid, otherwise the reason why it is not\n     */\n\n\n    ProtoTransactionCoreInfo.verify = function verify(message) {\n      if (typeof message !== \"object\" || message === null) return \"object expected\";\n      if (message.version != null && message.hasOwnProperty(\"version\")) if (!$util.isInteger(message.version)) return \"version: integer expected\";\n      if (message.nonce != null && message.hasOwnProperty(\"nonce\")) if (!$util.isInteger(message.nonce) && !(message.nonce && $util.isInteger(message.nonce.low) && $util.isInteger(message.nonce.high))) return \"nonce: integer|Long expected\";\n      if (message.toaddr != null && message.hasOwnProperty(\"toaddr\")) if (!(message.toaddr && typeof message.toaddr.length === \"number\" || $util.isString(message.toaddr))) return \"toaddr: buffer expected\";\n\n      if (message.senderpubkey != null && message.hasOwnProperty(\"senderpubkey\")) {\n        var error = $root.ZilliqaMessage.ByteArray.verify(message.senderpubkey);\n        if (error) return \"senderpubkey.\" + error;\n      }\n\n      if (message.amount != null && message.hasOwnProperty(\"amount\")) {\n        var error = $root.ZilliqaMessage.ByteArray.verify(message.amount);\n        if (error) return \"amount.\" + error;\n      }\n\n      if (message.gasprice != null && message.hasOwnProperty(\"gasprice\")) {\n        var error = $root.ZilliqaMessage.ByteArray.verify(message.gasprice);\n        if (error) return \"gasprice.\" + error;\n      }\n\n      if (message.gaslimit != null && message.hasOwnProperty(\"gaslimit\")) if (!$util.isInteger(message.gaslimit) && !(message.gaslimit && $util.isInteger(message.gaslimit.low) && $util.isInteger(message.gaslimit.high))) return \"gaslimit: integer|Long expected\";\n      if (message.code != null && message.hasOwnProperty(\"code\")) if (!(message.code && typeof message.code.length === \"number\" || $util.isString(message.code))) return \"code: buffer expected\";\n      if (message.data != null && message.hasOwnProperty(\"data\")) if (!(message.data && typeof message.data.length === \"number\" || $util.isString(message.data))) return \"data: buffer expected\";\n      return null;\n    };\n    /**\n     * Creates a ProtoTransactionCoreInfo message from a plain object. Also converts values to their respective internal types.\n     * @function fromObject\n     * @memberof ZilliqaMessage.ProtoTransactionCoreInfo\n     * @static\n     * @param {Object.<string,*>} object Plain object\n     * @returns {ZilliqaMessage.ProtoTransactionCoreInfo} ProtoTransactionCoreInfo\n     */\n\n\n    ProtoTransactionCoreInfo.fromObject = function fromObject(object) {\n      if (object instanceof $root.ZilliqaMessage.ProtoTransactionCoreInfo) return object;\n      var message = new $root.ZilliqaMessage.ProtoTransactionCoreInfo();\n      if (object.version != null) message.version = object.version >>> 0;\n      if (object.nonce != null) if ($util.Long) (message.nonce = $util.Long.fromValue(object.nonce)).unsigned = true;else if (typeof object.nonce === \"string\") message.nonce = parseInt(object.nonce, 10);else if (typeof object.nonce === \"number\") message.nonce = object.nonce;else if (typeof object.nonce === \"object\") message.nonce = new $util.LongBits(object.nonce.low >>> 0, object.nonce.high >>> 0).toNumber(true);\n      if (object.toaddr != null) if (typeof object.toaddr === \"string\") $util.base64.decode(object.toaddr, message.toaddr = $util.newBuffer($util.base64.length(object.toaddr)), 0);else if (object.toaddr.length) message.toaddr = object.toaddr;\n\n      if (object.senderpubkey != null) {\n        if (typeof object.senderpubkey !== \"object\") throw TypeError(\".ZilliqaMessage.ProtoTransactionCoreInfo.senderpubkey: object expected\");\n        message.senderpubkey = $root.ZilliqaMessage.ByteArray.fromObject(object.senderpubkey);\n      }\n\n      if (object.amount != null) {\n        if (typeof object.amount !== \"object\") throw TypeError(\".ZilliqaMessage.ProtoTransactionCoreInfo.amount: object expected\");\n        message.amount = $root.ZilliqaMessage.ByteArray.fromObject(object.amount);\n      }\n\n      if (object.gasprice != null) {\n        if (typeof object.gasprice !== \"object\") throw TypeError(\".ZilliqaMessage.ProtoTransactionCoreInfo.gasprice: object expected\");\n        message.gasprice = $root.ZilliqaMessage.ByteArray.fromObject(object.gasprice);\n      }\n\n      if (object.gaslimit != null) if ($util.Long) (message.gaslimit = $util.Long.fromValue(object.gaslimit)).unsigned = true;else if (typeof object.gaslimit === \"string\") message.gaslimit = parseInt(object.gaslimit, 10);else if (typeof object.gaslimit === \"number\") message.gaslimit = object.gaslimit;else if (typeof object.gaslimit === \"object\") message.gaslimit = new $util.LongBits(object.gaslimit.low >>> 0, object.gaslimit.high >>> 0).toNumber(true);\n      if (object.code != null) if (typeof object.code === \"string\") $util.base64.decode(object.code, message.code = $util.newBuffer($util.base64.length(object.code)), 0);else if (object.code.length) message.code = object.code;\n      if (object.data != null) if (typeof object.data === \"string\") $util.base64.decode(object.data, message.data = $util.newBuffer($util.base64.length(object.data)), 0);else if (object.data.length) message.data = object.data;\n      return message;\n    };\n    /**\n     * Creates a plain object from a ProtoTransactionCoreInfo message. Also converts values to other types if specified.\n     * @function toObject\n     * @memberof ZilliqaMessage.ProtoTransactionCoreInfo\n     * @static\n     * @param {ZilliqaMessage.ProtoTransactionCoreInfo} message ProtoTransactionCoreInfo\n     * @param {$protobuf.IConversionOptions} [options] Conversion options\n     * @returns {Object.<string,*>} Plain object\n     */\n\n\n    ProtoTransactionCoreInfo.toObject = function toObject(message, options) {\n      if (!options) options = {};\n      var object = {};\n\n      if (options.defaults) {\n        object.version = 0;\n\n        if ($util.Long) {\n          var long = new $util.Long(0, 0, true);\n          object.nonce = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n        } else object.nonce = options.longs === String ? \"0\" : 0;\n\n        if (options.bytes === String) object.toaddr = \"\";else {\n          object.toaddr = [];\n          if (options.bytes !== Array) object.toaddr = $util.newBuffer(object.toaddr);\n        }\n        object.senderpubkey = null;\n        object.amount = null;\n        object.gasprice = null;\n\n        if ($util.Long) {\n          var long = new $util.Long(0, 0, true);\n          object.gaslimit = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n        } else object.gaslimit = options.longs === String ? \"0\" : 0;\n\n        if (options.bytes === String) object.code = \"\";else {\n          object.code = [];\n          if (options.bytes !== Array) object.code = $util.newBuffer(object.code);\n        }\n        if (options.bytes === String) object.data = \"\";else {\n          object.data = [];\n          if (options.bytes !== Array) object.data = $util.newBuffer(object.data);\n        }\n      }\n\n      if (message.version != null && message.hasOwnProperty(\"version\")) object.version = message.version;\n      if (message.nonce != null && message.hasOwnProperty(\"nonce\")) if (typeof message.nonce === \"number\") object.nonce = options.longs === String ? String(message.nonce) : message.nonce;else object.nonce = options.longs === String ? $util.Long.prototype.toString.call(message.nonce) : options.longs === Number ? new $util.LongBits(message.nonce.low >>> 0, message.nonce.high >>> 0).toNumber(true) : message.nonce;\n      if (message.toaddr != null && message.hasOwnProperty(\"toaddr\")) object.toaddr = options.bytes === String ? $util.base64.encode(message.toaddr, 0, message.toaddr.length) : options.bytes === Array ? Array.prototype.slice.call(message.toaddr) : message.toaddr;\n      if (message.senderpubkey != null && message.hasOwnProperty(\"senderpubkey\")) object.senderpubkey = $root.ZilliqaMessage.ByteArray.toObject(message.senderpubkey, options);\n      if (message.amount != null && message.hasOwnProperty(\"amount\")) object.amount = $root.ZilliqaMessage.ByteArray.toObject(message.amount, options);\n      if (message.gasprice != null && message.hasOwnProperty(\"gasprice\")) object.gasprice = $root.ZilliqaMessage.ByteArray.toObject(message.gasprice, options);\n      if (message.gaslimit != null && message.hasOwnProperty(\"gaslimit\")) if (typeof message.gaslimit === \"number\") object.gaslimit = options.longs === String ? String(message.gaslimit) : message.gaslimit;else object.gaslimit = options.longs === String ? $util.Long.prototype.toString.call(message.gaslimit) : options.longs === Number ? new $util.LongBits(message.gaslimit.low >>> 0, message.gaslimit.high >>> 0).toNumber(true) : message.gaslimit;\n      if (message.code != null && message.hasOwnProperty(\"code\")) object.code = options.bytes === String ? $util.base64.encode(message.code, 0, message.code.length) : options.bytes === Array ? Array.prototype.slice.call(message.code) : message.code;\n      if (message.data != null && message.hasOwnProperty(\"data\")) object.data = options.bytes === String ? $util.base64.encode(message.data, 0, message.data.length) : options.bytes === Array ? Array.prototype.slice.call(message.data) : message.data;\n      return object;\n    };\n    /**\n     * Converts this ProtoTransactionCoreInfo to JSON.\n     * @function toJSON\n     * @memberof ZilliqaMessage.ProtoTransactionCoreInfo\n     * @instance\n     * @returns {Object.<string,*>} JSON object\n     */\n\n\n    ProtoTransactionCoreInfo.prototype.toJSON = function toJSON() {\n      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n    };\n\n    return ProtoTransactionCoreInfo;\n  }();\n\n  ZilliqaMessage.ProtoTransaction = function () {\n    /**\n     * Properties of a ProtoTransaction.\n     * @memberof ZilliqaMessage\n     * @interface IProtoTransaction\n     * @property {Uint8Array|null} [tranid] ProtoTransaction tranid\n     * @property {ZilliqaMessage.IProtoTransactionCoreInfo|null} [info] ProtoTransaction info\n     * @property {ZilliqaMessage.IByteArray|null} [signature] ProtoTransaction signature\n     */\n\n    /**\n     * Constructs a new ProtoTransaction.\n     * @memberof ZilliqaMessage\n     * @classdesc Represents a ProtoTransaction.\n     * @implements IProtoTransaction\n     * @constructor\n     * @param {ZilliqaMessage.IProtoTransaction=} [properties] Properties to set\n     */\n    function ProtoTransaction(properties) {\n      if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * ProtoTransaction tranid.\n     * @member {Uint8Array} tranid\n     * @memberof ZilliqaMessage.ProtoTransaction\n     * @instance\n     */\n\n\n    ProtoTransaction.prototype.tranid = $util.newBuffer([]);\n    /**\n     * ProtoTransaction info.\n     * @member {ZilliqaMessage.IProtoTransactionCoreInfo|null|undefined} info\n     * @memberof ZilliqaMessage.ProtoTransaction\n     * @instance\n     */\n\n    ProtoTransaction.prototype.info = null;\n    /**\n     * ProtoTransaction signature.\n     * @member {ZilliqaMessage.IByteArray|null|undefined} signature\n     * @memberof ZilliqaMessage.ProtoTransaction\n     * @instance\n     */\n\n    ProtoTransaction.prototype.signature = null;\n    /**\n     * Creates a new ProtoTransaction instance using the specified properties.\n     * @function create\n     * @memberof ZilliqaMessage.ProtoTransaction\n     * @static\n     * @param {ZilliqaMessage.IProtoTransaction=} [properties] Properties to set\n     * @returns {ZilliqaMessage.ProtoTransaction} ProtoTransaction instance\n     */\n\n    ProtoTransaction.create = function create(properties) {\n      return new ProtoTransaction(properties);\n    };\n    /**\n     * Encodes the specified ProtoTransaction message. Does not implicitly {@link ZilliqaMessage.ProtoTransaction.verify|verify} messages.\n     * @function encode\n     * @memberof ZilliqaMessage.ProtoTransaction\n     * @static\n     * @param {ZilliqaMessage.IProtoTransaction} message ProtoTransaction message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n\n\n    ProtoTransaction.encode = function encode(message, writer) {\n      if (!writer) writer = $Writer.create();\n      if (message.tranid != null && message.hasOwnProperty(\"tranid\")) writer.uint32(\n      /* id 1, wireType 2 =*/\n      10).bytes(message.tranid);\n      if (message.info != null && message.hasOwnProperty(\"info\")) $root.ZilliqaMessage.ProtoTransactionCoreInfo.encode(message.info, writer.uint32(\n      /* id 2, wireType 2 =*/\n      18).fork()).ldelim();\n      if (message.signature != null && message.hasOwnProperty(\"signature\")) $root.ZilliqaMessage.ByteArray.encode(message.signature, writer.uint32(\n      /* id 3, wireType 2 =*/\n      26).fork()).ldelim();\n      return writer;\n    };\n    /**\n     * Encodes the specified ProtoTransaction message, length delimited. Does not implicitly {@link ZilliqaMessage.ProtoTransaction.verify|verify} messages.\n     * @function encodeDelimited\n     * @memberof ZilliqaMessage.ProtoTransaction\n     * @static\n     * @param {ZilliqaMessage.IProtoTransaction} message ProtoTransaction message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n\n\n    ProtoTransaction.encodeDelimited = function encodeDelimited(message, writer) {\n      return this.encode(message, writer).ldelim();\n    };\n    /**\n     * Decodes a ProtoTransaction message from the specified reader or buffer.\n     * @function decode\n     * @memberof ZilliqaMessage.ProtoTransaction\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {ZilliqaMessage.ProtoTransaction} ProtoTransaction\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n\n\n    ProtoTransaction.decode = function decode(reader, length) {\n      if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n      var end = length === undefined ? reader.len : reader.pos + length,\n          message = new $root.ZilliqaMessage.ProtoTransaction();\n\n      while (reader.pos < end) {\n        var tag = reader.uint32();\n\n        switch (tag >>> 3) {\n          case 1:\n            message.tranid = reader.bytes();\n            break;\n\n          case 2:\n            message.info = $root.ZilliqaMessage.ProtoTransactionCoreInfo.decode(reader, reader.uint32());\n            break;\n\n          case 3:\n            message.signature = $root.ZilliqaMessage.ByteArray.decode(reader, reader.uint32());\n            break;\n\n          default:\n            reader.skipType(tag & 7);\n            break;\n        }\n      }\n\n      return message;\n    };\n    /**\n     * Decodes a ProtoTransaction message from the specified reader or buffer, length delimited.\n     * @function decodeDelimited\n     * @memberof ZilliqaMessage.ProtoTransaction\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @returns {ZilliqaMessage.ProtoTransaction} ProtoTransaction\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n\n\n    ProtoTransaction.decodeDelimited = function decodeDelimited(reader) {\n      if (!(reader instanceof $Reader)) reader = new $Reader(reader);\n      return this.decode(reader, reader.uint32());\n    };\n    /**\n     * Verifies a ProtoTransaction message.\n     * @function verify\n     * @memberof ZilliqaMessage.ProtoTransaction\n     * @static\n     * @param {Object.<string,*>} message Plain object to verify\n     * @returns {string|null} `null` if valid, otherwise the reason why it is not\n     */\n\n\n    ProtoTransaction.verify = function verify(message) {\n      if (typeof message !== \"object\" || message === null) return \"object expected\";\n      if (message.tranid != null && message.hasOwnProperty(\"tranid\")) if (!(message.tranid && typeof message.tranid.length === \"number\" || $util.isString(message.tranid))) return \"tranid: buffer expected\";\n\n      if (message.info != null && message.hasOwnProperty(\"info\")) {\n        var error = $root.ZilliqaMessage.ProtoTransactionCoreInfo.verify(message.info);\n        if (error) return \"info.\" + error;\n      }\n\n      if (message.signature != null && message.hasOwnProperty(\"signature\")) {\n        var error = $root.ZilliqaMessage.ByteArray.verify(message.signature);\n        if (error) return \"signature.\" + error;\n      }\n\n      return null;\n    };\n    /**\n     * Creates a ProtoTransaction message from a plain object. Also converts values to their respective internal types.\n     * @function fromObject\n     * @memberof ZilliqaMessage.ProtoTransaction\n     * @static\n     * @param {Object.<string,*>} object Plain object\n     * @returns {ZilliqaMessage.ProtoTransaction} ProtoTransaction\n     */\n\n\n    ProtoTransaction.fromObject = function fromObject(object) {\n      if (object instanceof $root.ZilliqaMessage.ProtoTransaction) return object;\n      var message = new $root.ZilliqaMessage.ProtoTransaction();\n      if (object.tranid != null) if (typeof object.tranid === \"string\") $util.base64.decode(object.tranid, message.tranid = $util.newBuffer($util.base64.length(object.tranid)), 0);else if (object.tranid.length) message.tranid = object.tranid;\n\n      if (object.info != null) {\n        if (typeof object.info !== \"object\") throw TypeError(\".ZilliqaMessage.ProtoTransaction.info: object expected\");\n        message.info = $root.ZilliqaMessage.ProtoTransactionCoreInfo.fromObject(object.info);\n      }\n\n      if (object.signature != null) {\n        if (typeof object.signature !== \"object\") throw TypeError(\".ZilliqaMessage.ProtoTransaction.signature: object expected\");\n        message.signature = $root.ZilliqaMessage.ByteArray.fromObject(object.signature);\n      }\n\n      return message;\n    };\n    /**\n     * Creates a plain object from a ProtoTransaction message. Also converts values to other types if specified.\n     * @function toObject\n     * @memberof ZilliqaMessage.ProtoTransaction\n     * @static\n     * @param {ZilliqaMessage.ProtoTransaction} message ProtoTransaction\n     * @param {$protobuf.IConversionOptions} [options] Conversion options\n     * @returns {Object.<string,*>} Plain object\n     */\n\n\n    ProtoTransaction.toObject = function toObject(message, options) {\n      if (!options) options = {};\n      var object = {};\n\n      if (options.defaults) {\n        if (options.bytes === String) object.tranid = \"\";else {\n          object.tranid = [];\n          if (options.bytes !== Array) object.tranid = $util.newBuffer(object.tranid);\n        }\n        object.info = null;\n        object.signature = null;\n      }\n\n      if (message.tranid != null && message.hasOwnProperty(\"tranid\")) object.tranid = options.bytes === String ? $util.base64.encode(message.tranid, 0, message.tranid.length) : options.bytes === Array ? Array.prototype.slice.call(message.tranid) : message.tranid;\n      if (message.info != null && message.hasOwnProperty(\"info\")) object.info = $root.ZilliqaMessage.ProtoTransactionCoreInfo.toObject(message.info, options);\n      if (message.signature != null && message.hasOwnProperty(\"signature\")) object.signature = $root.ZilliqaMessage.ByteArray.toObject(message.signature, options);\n      return object;\n    };\n    /**\n     * Converts this ProtoTransaction to JSON.\n     * @function toJSON\n     * @memberof ZilliqaMessage.ProtoTransaction\n     * @instance\n     * @returns {Object.<string,*>} JSON object\n     */\n\n\n    ProtoTransaction.prototype.toJSON = function toJSON() {\n      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n    };\n\n    return ProtoTransaction;\n  }();\n\n  ZilliqaMessage.ProtoTransactionReceipt = function () {\n    /**\n     * Properties of a ProtoTransactionReceipt.\n     * @memberof ZilliqaMessage\n     * @interface IProtoTransactionReceipt\n     * @property {Uint8Array|null} [receipt] ProtoTransactionReceipt receipt\n     * @property {number|Long|null} [cumgas] ProtoTransactionReceipt cumgas\n     */\n\n    /**\n     * Constructs a new ProtoTransactionReceipt.\n     * @memberof ZilliqaMessage\n     * @classdesc Represents a ProtoTransactionReceipt.\n     * @implements IProtoTransactionReceipt\n     * @constructor\n     * @param {ZilliqaMessage.IProtoTransactionReceipt=} [properties] Properties to set\n     */\n    function ProtoTransactionReceipt(properties) {\n      if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * ProtoTransactionReceipt receipt.\n     * @member {Uint8Array} receipt\n     * @memberof ZilliqaMessage.ProtoTransactionReceipt\n     * @instance\n     */\n\n\n    ProtoTransactionReceipt.prototype.receipt = $util.newBuffer([]);\n    /**\n     * ProtoTransactionReceipt cumgas.\n     * @member {number|Long} cumgas\n     * @memberof ZilliqaMessage.ProtoTransactionReceipt\n     * @instance\n     */\n\n    ProtoTransactionReceipt.prototype.cumgas = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;\n    /**\n     * Creates a new ProtoTransactionReceipt instance using the specified properties.\n     * @function create\n     * @memberof ZilliqaMessage.ProtoTransactionReceipt\n     * @static\n     * @param {ZilliqaMessage.IProtoTransactionReceipt=} [properties] Properties to set\n     * @returns {ZilliqaMessage.ProtoTransactionReceipt} ProtoTransactionReceipt instance\n     */\n\n    ProtoTransactionReceipt.create = function create(properties) {\n      return new ProtoTransactionReceipt(properties);\n    };\n    /**\n     * Encodes the specified ProtoTransactionReceipt message. Does not implicitly {@link ZilliqaMessage.ProtoTransactionReceipt.verify|verify} messages.\n     * @function encode\n     * @memberof ZilliqaMessage.ProtoTransactionReceipt\n     * @static\n     * @param {ZilliqaMessage.IProtoTransactionReceipt} message ProtoTransactionReceipt message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n\n\n    ProtoTransactionReceipt.encode = function encode(message, writer) {\n      if (!writer) writer = $Writer.create();\n      if (message.receipt != null && message.hasOwnProperty(\"receipt\")) writer.uint32(\n      /* id 1, wireType 2 =*/\n      10).bytes(message.receipt);\n      if (message.cumgas != null && message.hasOwnProperty(\"cumgas\")) writer.uint32(\n      /* id 2, wireType 0 =*/\n      16).uint64(message.cumgas);\n      return writer;\n    };\n    /**\n     * Encodes the specified ProtoTransactionReceipt message, length delimited. Does not implicitly {@link ZilliqaMessage.ProtoTransactionReceipt.verify|verify} messages.\n     * @function encodeDelimited\n     * @memberof ZilliqaMessage.ProtoTransactionReceipt\n     * @static\n     * @param {ZilliqaMessage.IProtoTransactionReceipt} message ProtoTransactionReceipt message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n\n\n    ProtoTransactionReceipt.encodeDelimited = function encodeDelimited(message, writer) {\n      return this.encode(message, writer).ldelim();\n    };\n    /**\n     * Decodes a ProtoTransactionReceipt message from the specified reader or buffer.\n     * @function decode\n     * @memberof ZilliqaMessage.ProtoTransactionReceipt\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {ZilliqaMessage.ProtoTransactionReceipt} ProtoTransactionReceipt\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n\n\n    ProtoTransactionReceipt.decode = function decode(reader, length) {\n      if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n      var end = length === undefined ? reader.len : reader.pos + length,\n          message = new $root.ZilliqaMessage.ProtoTransactionReceipt();\n\n      while (reader.pos < end) {\n        var tag = reader.uint32();\n\n        switch (tag >>> 3) {\n          case 1:\n            message.receipt = reader.bytes();\n            break;\n\n          case 2:\n            message.cumgas = reader.uint64();\n            break;\n\n          default:\n            reader.skipType(tag & 7);\n            break;\n        }\n      }\n\n      return message;\n    };\n    /**\n     * Decodes a ProtoTransactionReceipt message from the specified reader or buffer, length delimited.\n     * @function decodeDelimited\n     * @memberof ZilliqaMessage.ProtoTransactionReceipt\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @returns {ZilliqaMessage.ProtoTransactionReceipt} ProtoTransactionReceipt\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n\n\n    ProtoTransactionReceipt.decodeDelimited = function decodeDelimited(reader) {\n      if (!(reader instanceof $Reader)) reader = new $Reader(reader);\n      return this.decode(reader, reader.uint32());\n    };\n    /**\n     * Verifies a ProtoTransactionReceipt message.\n     * @function verify\n     * @memberof ZilliqaMessage.ProtoTransactionReceipt\n     * @static\n     * @param {Object.<string,*>} message Plain object to verify\n     * @returns {string|null} `null` if valid, otherwise the reason why it is not\n     */\n\n\n    ProtoTransactionReceipt.verify = function verify(message) {\n      if (typeof message !== \"object\" || message === null) return \"object expected\";\n      if (message.receipt != null && message.hasOwnProperty(\"receipt\")) if (!(message.receipt && typeof message.receipt.length === \"number\" || $util.isString(message.receipt))) return \"receipt: buffer expected\";\n      if (message.cumgas != null && message.hasOwnProperty(\"cumgas\")) if (!$util.isInteger(message.cumgas) && !(message.cumgas && $util.isInteger(message.cumgas.low) && $util.isInteger(message.cumgas.high))) return \"cumgas: integer|Long expected\";\n      return null;\n    };\n    /**\n     * Creates a ProtoTransactionReceipt message from a plain object. Also converts values to their respective internal types.\n     * @function fromObject\n     * @memberof ZilliqaMessage.ProtoTransactionReceipt\n     * @static\n     * @param {Object.<string,*>} object Plain object\n     * @returns {ZilliqaMessage.ProtoTransactionReceipt} ProtoTransactionReceipt\n     */\n\n\n    ProtoTransactionReceipt.fromObject = function fromObject(object) {\n      if (object instanceof $root.ZilliqaMessage.ProtoTransactionReceipt) return object;\n      var message = new $root.ZilliqaMessage.ProtoTransactionReceipt();\n      if (object.receipt != null) if (typeof object.receipt === \"string\") $util.base64.decode(object.receipt, message.receipt = $util.newBuffer($util.base64.length(object.receipt)), 0);else if (object.receipt.length) message.receipt = object.receipt;\n      if (object.cumgas != null) if ($util.Long) (message.cumgas = $util.Long.fromValue(object.cumgas)).unsigned = true;else if (typeof object.cumgas === \"string\") message.cumgas = parseInt(object.cumgas, 10);else if (typeof object.cumgas === \"number\") message.cumgas = object.cumgas;else if (typeof object.cumgas === \"object\") message.cumgas = new $util.LongBits(object.cumgas.low >>> 0, object.cumgas.high >>> 0).toNumber(true);\n      return message;\n    };\n    /**\n     * Creates a plain object from a ProtoTransactionReceipt message. Also converts values to other types if specified.\n     * @function toObject\n     * @memberof ZilliqaMessage.ProtoTransactionReceipt\n     * @static\n     * @param {ZilliqaMessage.ProtoTransactionReceipt} message ProtoTransactionReceipt\n     * @param {$protobuf.IConversionOptions} [options] Conversion options\n     * @returns {Object.<string,*>} Plain object\n     */\n\n\n    ProtoTransactionReceipt.toObject = function toObject(message, options) {\n      if (!options) options = {};\n      var object = {};\n\n      if (options.defaults) {\n        if (options.bytes === String) object.receipt = \"\";else {\n          object.receipt = [];\n          if (options.bytes !== Array) object.receipt = $util.newBuffer(object.receipt);\n        }\n\n        if ($util.Long) {\n          var long = new $util.Long(0, 0, true);\n          object.cumgas = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n        } else object.cumgas = options.longs === String ? \"0\" : 0;\n      }\n\n      if (message.receipt != null && message.hasOwnProperty(\"receipt\")) object.receipt = options.bytes === String ? $util.base64.encode(message.receipt, 0, message.receipt.length) : options.bytes === Array ? Array.prototype.slice.call(message.receipt) : message.receipt;\n      if (message.cumgas != null && message.hasOwnProperty(\"cumgas\")) if (typeof message.cumgas === \"number\") object.cumgas = options.longs === String ? String(message.cumgas) : message.cumgas;else object.cumgas = options.longs === String ? $util.Long.prototype.toString.call(message.cumgas) : options.longs === Number ? new $util.LongBits(message.cumgas.low >>> 0, message.cumgas.high >>> 0).toNumber(true) : message.cumgas;\n      return object;\n    };\n    /**\n     * Converts this ProtoTransactionReceipt to JSON.\n     * @function toJSON\n     * @memberof ZilliqaMessage.ProtoTransactionReceipt\n     * @instance\n     * @returns {Object.<string,*>} JSON object\n     */\n\n\n    ProtoTransactionReceipt.prototype.toJSON = function toJSON() {\n      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n    };\n\n    return ProtoTransactionReceipt;\n  }();\n\n  ZilliqaMessage.ProtoTransactionWithReceipt = function () {\n    /**\n     * Properties of a ProtoTransactionWithReceipt.\n     * @memberof ZilliqaMessage\n     * @interface IProtoTransactionWithReceipt\n     * @property {ZilliqaMessage.IProtoTransaction|null} [transaction] ProtoTransactionWithReceipt transaction\n     * @property {ZilliqaMessage.IProtoTransactionReceipt|null} [receipt] ProtoTransactionWithReceipt receipt\n     */\n\n    /**\n     * Constructs a new ProtoTransactionWithReceipt.\n     * @memberof ZilliqaMessage\n     * @classdesc Represents a ProtoTransactionWithReceipt.\n     * @implements IProtoTransactionWithReceipt\n     * @constructor\n     * @param {ZilliqaMessage.IProtoTransactionWithReceipt=} [properties] Properties to set\n     */\n    function ProtoTransactionWithReceipt(properties) {\n      if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * ProtoTransactionWithReceipt transaction.\n     * @member {ZilliqaMessage.IProtoTransaction|null|undefined} transaction\n     * @memberof ZilliqaMessage.ProtoTransactionWithReceipt\n     * @instance\n     */\n\n\n    ProtoTransactionWithReceipt.prototype.transaction = null;\n    /**\n     * ProtoTransactionWithReceipt receipt.\n     * @member {ZilliqaMessage.IProtoTransactionReceipt|null|undefined} receipt\n     * @memberof ZilliqaMessage.ProtoTransactionWithReceipt\n     * @instance\n     */\n\n    ProtoTransactionWithReceipt.prototype.receipt = null;\n    /**\n     * Creates a new ProtoTransactionWithReceipt instance using the specified properties.\n     * @function create\n     * @memberof ZilliqaMessage.ProtoTransactionWithReceipt\n     * @static\n     * @param {ZilliqaMessage.IProtoTransactionWithReceipt=} [properties] Properties to set\n     * @returns {ZilliqaMessage.ProtoTransactionWithReceipt} ProtoTransactionWithReceipt instance\n     */\n\n    ProtoTransactionWithReceipt.create = function create(properties) {\n      return new ProtoTransactionWithReceipt(properties);\n    };\n    /**\n     * Encodes the specified ProtoTransactionWithReceipt message. Does not implicitly {@link ZilliqaMessage.ProtoTransactionWithReceipt.verify|verify} messages.\n     * @function encode\n     * @memberof ZilliqaMessage.ProtoTransactionWithReceipt\n     * @static\n     * @param {ZilliqaMessage.IProtoTransactionWithReceipt} message ProtoTransactionWithReceipt message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n\n\n    ProtoTransactionWithReceipt.encode = function encode(message, writer) {\n      if (!writer) writer = $Writer.create();\n      if (message.transaction != null && message.hasOwnProperty(\"transaction\")) $root.ZilliqaMessage.ProtoTransaction.encode(message.transaction, writer.uint32(\n      /* id 1, wireType 2 =*/\n      10).fork()).ldelim();\n      if (message.receipt != null && message.hasOwnProperty(\"receipt\")) $root.ZilliqaMessage.ProtoTransactionReceipt.encode(message.receipt, writer.uint32(\n      /* id 2, wireType 2 =*/\n      18).fork()).ldelim();\n      return writer;\n    };\n    /**\n     * Encodes the specified ProtoTransactionWithReceipt message, length delimited. Does not implicitly {@link ZilliqaMessage.ProtoTransactionWithReceipt.verify|verify} messages.\n     * @function encodeDelimited\n     * @memberof ZilliqaMessage.ProtoTransactionWithReceipt\n     * @static\n     * @param {ZilliqaMessage.IProtoTransactionWithReceipt} message ProtoTransactionWithReceipt message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n\n\n    ProtoTransactionWithReceipt.encodeDelimited = function encodeDelimited(message, writer) {\n      return this.encode(message, writer).ldelim();\n    };\n    /**\n     * Decodes a ProtoTransactionWithReceipt message from the specified reader or buffer.\n     * @function decode\n     * @memberof ZilliqaMessage.ProtoTransactionWithReceipt\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {ZilliqaMessage.ProtoTransactionWithReceipt} ProtoTransactionWithReceipt\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n\n\n    ProtoTransactionWithReceipt.decode = function decode(reader, length) {\n      if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n      var end = length === undefined ? reader.len : reader.pos + length,\n          message = new $root.ZilliqaMessage.ProtoTransactionWithReceipt();\n\n      while (reader.pos < end) {\n        var tag = reader.uint32();\n\n        switch (tag >>> 3) {\n          case 1:\n            message.transaction = $root.ZilliqaMessage.ProtoTransaction.decode(reader, reader.uint32());\n            break;\n\n          case 2:\n            message.receipt = $root.ZilliqaMessage.ProtoTransactionReceipt.decode(reader, reader.uint32());\n            break;\n\n          default:\n            reader.skipType(tag & 7);\n            break;\n        }\n      }\n\n      return message;\n    };\n    /**\n     * Decodes a ProtoTransactionWithReceipt message from the specified reader or buffer, length delimited.\n     * @function decodeDelimited\n     * @memberof ZilliqaMessage.ProtoTransactionWithReceipt\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @returns {ZilliqaMessage.ProtoTransactionWithReceipt} ProtoTransactionWithReceipt\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n\n\n    ProtoTransactionWithReceipt.decodeDelimited = function decodeDelimited(reader) {\n      if (!(reader instanceof $Reader)) reader = new $Reader(reader);\n      return this.decode(reader, reader.uint32());\n    };\n    /**\n     * Verifies a ProtoTransactionWithReceipt message.\n     * @function verify\n     * @memberof ZilliqaMessage.ProtoTransactionWithReceipt\n     * @static\n     * @param {Object.<string,*>} message Plain object to verify\n     * @returns {string|null} `null` if valid, otherwise the reason why it is not\n     */\n\n\n    ProtoTransactionWithReceipt.verify = function verify(message) {\n      if (typeof message !== \"object\" || message === null) return \"object expected\";\n\n      if (message.transaction != null && message.hasOwnProperty(\"transaction\")) {\n        var error = $root.ZilliqaMessage.ProtoTransaction.verify(message.transaction);\n        if (error) return \"transaction.\" + error;\n      }\n\n      if (message.receipt != null && message.hasOwnProperty(\"receipt\")) {\n        var error = $root.ZilliqaMessage.ProtoTransactionReceipt.verify(message.receipt);\n        if (error) return \"receipt.\" + error;\n      }\n\n      return null;\n    };\n    /**\n     * Creates a ProtoTransactionWithReceipt message from a plain object. Also converts values to their respective internal types.\n     * @function fromObject\n     * @memberof ZilliqaMessage.ProtoTransactionWithReceipt\n     * @static\n     * @param {Object.<string,*>} object Plain object\n     * @returns {ZilliqaMessage.ProtoTransactionWithReceipt} ProtoTransactionWithReceipt\n     */\n\n\n    ProtoTransactionWithReceipt.fromObject = function fromObject(object) {\n      if (object instanceof $root.ZilliqaMessage.ProtoTransactionWithReceipt) return object;\n      var message = new $root.ZilliqaMessage.ProtoTransactionWithReceipt();\n\n      if (object.transaction != null) {\n        if (typeof object.transaction !== \"object\") throw TypeError(\".ZilliqaMessage.ProtoTransactionWithReceipt.transaction: object expected\");\n        message.transaction = $root.ZilliqaMessage.ProtoTransaction.fromObject(object.transaction);\n      }\n\n      if (object.receipt != null) {\n        if (typeof object.receipt !== \"object\") throw TypeError(\".ZilliqaMessage.ProtoTransactionWithReceipt.receipt: object expected\");\n        message.receipt = $root.ZilliqaMessage.ProtoTransactionReceipt.fromObject(object.receipt);\n      }\n\n      return message;\n    };\n    /**\n     * Creates a plain object from a ProtoTransactionWithReceipt message. Also converts values to other types if specified.\n     * @function toObject\n     * @memberof ZilliqaMessage.ProtoTransactionWithReceipt\n     * @static\n     * @param {ZilliqaMessage.ProtoTransactionWithReceipt} message ProtoTransactionWithReceipt\n     * @param {$protobuf.IConversionOptions} [options] Conversion options\n     * @returns {Object.<string,*>} Plain object\n     */\n\n\n    ProtoTransactionWithReceipt.toObject = function toObject(message, options) {\n      if (!options) options = {};\n      var object = {};\n\n      if (options.defaults) {\n        object.transaction = null;\n        object.receipt = null;\n      }\n\n      if (message.transaction != null && message.hasOwnProperty(\"transaction\")) object.transaction = $root.ZilliqaMessage.ProtoTransaction.toObject(message.transaction, options);\n      if (message.receipt != null && message.hasOwnProperty(\"receipt\")) object.receipt = $root.ZilliqaMessage.ProtoTransactionReceipt.toObject(message.receipt, options);\n      return object;\n    };\n    /**\n     * Converts this ProtoTransactionWithReceipt to JSON.\n     * @function toJSON\n     * @memberof ZilliqaMessage.ProtoTransactionWithReceipt\n     * @instance\n     * @returns {Object.<string,*>} JSON object\n     */\n\n\n    ProtoTransactionWithReceipt.prototype.toJSON = function toJSON() {\n      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n    };\n\n    return ProtoTransactionWithReceipt;\n  }();\n\n  return ZilliqaMessage;\n}();\n\nmodule.exports = $root;","map":null,"metadata":{},"sourceType":"script"}